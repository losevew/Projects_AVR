
tester.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ca8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  00001ca8  00001d5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000059  00800064  00800064  00001d60  2**0
                  ALLOC
  3 .eeprom       00000160  00810000  00810000  00001d60  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000e64  00000000  00000000  00001ec0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000345  00000000  00000000  00002d24  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000060  00000000  00000000  00003070  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000048f  00000000  00000000  000030d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00001ebc  00000000  00000000  0000355f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000003c7  00000000  00000000  0000541b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001e11  00000000  00000000  000057e2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000110  00000000  00000000  000075f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000417  00000000  00000000  00007704  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000124e  00000000  00000000  00007b1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubtypes 0000007a  00000000  00000000  00008d69  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
       2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
       4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
       6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
       8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
       a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
       c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
       e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
      10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
      12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
      14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
      16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
      18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
      1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
      1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
      1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
      20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
      22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
      24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
      26:	11 24       	eor	r1, r1
      28:	1f be       	out	0x3f, r1	; 63
      2a:	cf e5       	ldi	r28, 0x5F	; 95
      2c:	d4 e0       	ldi	r29, 0x04	; 4
      2e:	de bf       	out	0x3e, r29	; 62
      30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
      32:	10 e0       	ldi	r17, 0x00	; 0
      34:	a0 e6       	ldi	r26, 0x60	; 96
      36:	b0 e0       	ldi	r27, 0x00	; 0
      38:	e8 ea       	ldi	r30, 0xA8	; 168
      3a:	fc e1       	ldi	r31, 0x1C	; 28
      3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
      3e:	05 90       	lpm	r0, Z+
      40:	0d 92       	st	X+, r0
      42:	a4 36       	cpi	r26, 0x64	; 100
      44:	b1 07       	cpc	r27, r17
      46:	d9 f7       	brne	.-10     	; 0x3e <__SP_H__>

00000048 <__do_clear_bss>:
      48:	10 e0       	ldi	r17, 0x00	; 0
      4a:	a4 e6       	ldi	r26, 0x64	; 100
      4c:	b0 e0       	ldi	r27, 0x00	; 0
      4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
      50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
      52:	ad 3b       	cpi	r26, 0xBD	; 189
      54:	b1 07       	cpc	r27, r17
      56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
      58:	34 d8       	rcall	.-3992   	; 0xfffff0c2 <__eeprom_end+0xff7eef62>
      5a:	24 ce       	rjmp	.-952    	; 0xfffffca4 <__eeprom_end+0xff7efb44>

0000005c <__bad_interrupt>:
      5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <lcd_enable>:
}

// erzeugt den Enable-Puls
void lcd_enable(void)
{
	LCD_PORT |= (1<<LCD_EN1);
      5e:	95 9a       	sbi	0x12, 5	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      60:	83 e0       	ldi	r24, 0x03	; 3
      62:	8a 95       	dec	r24
      64:	f1 f7       	brne	.-4      	; 0x62 <lcd_enable+0x4>
      66:	00 00       	nop
    _delay_us(10);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN1);
      68:	95 98       	cbi	0x12, 5	; 18
}
      6a:	08 95       	ret

0000006c <lcd_send>:
		uart_newline();
	}
}

//Eigentliche LCD-Zugriffs-Funktion; 4-Bit-Modus
void lcd_send(unsigned char data) {
      6c:	df 93       	push	r29
      6e:	cf 93       	push	r28
      70:	0f 92       	push	r0
      72:	cd b7       	in	r28, 0x3d	; 61
      74:	de b7       	in	r29, 0x3e	; 62
   // oberes Nibble setzen
  LCD_PORT = (LCD_PORT & 0xF0) | ((data >> 4) & 0x0F);
      76:	22 b3       	in	r18, 0x12	; 18
      78:	98 2f       	mov	r25, r24
      7a:	92 95       	swap	r25
      7c:	9f 70       	andi	r25, 0x0F	; 15
      7e:	20 7f       	andi	r18, 0xF0	; 240
      80:	92 2b       	or	r25, r18
      82:	92 bb       	out	0x12, r25	; 18
      84:	00 c0       	rjmp	.+0      	; 0x86 <lcd_send+0x1a>
      86:	00 c0       	rjmp	.+0      	; 0x88 <lcd_send+0x1c>
      88:	00 00       	nop
  _delay_us(5);
  lcd_enable();
      8a:	89 83       	std	Y+1, r24	; 0x01
      8c:	e8 df       	rcall	.-48     	; 0x5e <lcd_enable>
   // unteres Nibble setzen
  LCD_PORT = (LCD_PORT & 0xF0) | (data & 0x0F);
      8e:	92 b3       	in	r25, 0x12	; 18
      90:	89 81       	ldd	r24, Y+1	; 0x01
      92:	8f 70       	andi	r24, 0x0F	; 15
      94:	90 7f       	andi	r25, 0xF0	; 240
      96:	89 2b       	or	r24, r25
      98:	82 bb       	out	0x12, r24	; 18
      9a:	00 c0       	rjmp	.+0      	; 0x9c <lcd_send+0x30>
      9c:	00 c0       	rjmp	.+0      	; 0x9e <lcd_send+0x32>
      9e:	00 00       	nop
  _delay_us(5);
  lcd_enable();
      a0:	de df       	rcall	.-68     	; 0x5e <lcd_enable>
      a2:	84 e1       	ldi	r24, 0x14	; 20
      a4:	8a 95       	dec	r24
      a6:	f1 f7       	brne	.-4      	; 0xa4 <lcd_send+0x38>
  _delay_us(60);  
  LCD_PORT &= 0xF0;
      a8:	82 b3       	in	r24, 0x12	; 18
      aa:	80 7f       	andi	r24, 0xF0	; 240
      ac:	82 bb       	out	0x12, r24	; 18
}
      ae:	0f 90       	pop	r0
      b0:	cf 91       	pop	r28
      b2:	df 91       	pop	r29
      b4:	08 95       	ret

000000b6 <lcd_data>:

 
// sendet ein Datenbyte an das LCD
 
void lcd_data(unsigned char temp1)
{
      b6:	1f 93       	push	r17
      b8:	18 2f       	mov	r17, r24
	LCD_PORT |= (1<<LCD_RS);        // RS auf 1 setzen
      ba:	94 9a       	sbi	0x12, 4	; 18
	lcd_send(temp1);
      bc:	d7 df       	rcall	.-82     	; 0x6c <lcd_send>
	switch(temp1) {
      be:	11 3e       	cpi	r17, 0xE1	; 225
      c0:	61 f0       	breq	.+24     	; 0xda <lcd_data+0x24>
      c2:	12 3e       	cpi	r17, 0xE2	; 226
      c4:	18 f4       	brcc	.+6      	; 0xcc <lcd_data+0x16>
      c6:	11 23       	and	r17, r17
      c8:	31 f0       	breq	.+12     	; 0xd6 <lcd_data+0x20>
      ca:	0b c0       	rjmp	.+22     	; 0xe2 <lcd_data+0x2c>
      cc:	14 3e       	cpi	r17, 0xE4	; 228
      ce:	39 f0       	breq	.+14     	; 0xde <lcd_data+0x28>
      d0:	14 3f       	cpi	r17, 0xF4	; 244
      d2:	39 f4       	brne	.+14     	; 0xe2 <lcd_data+0x2c>
      d4:	08 c0       	rjmp	.+16     	; 0xe6 <lcd_data+0x30>
		case 0:
			uart_putc('#');
      d6:	83 e2       	ldi	r24, 0x23	; 35
      d8:	05 c0       	rjmp	.+10     	; 0xe4 <lcd_data+0x2e>
			break;
		case 225:	//ä
			uart_putc('ä');
      da:	84 ee       	ldi	r24, 0xE4	; 228
      dc:	03 c0       	rjmp	.+6      	; 0xe4 <lcd_data+0x2e>
			break;
		case 228:	//µ
			uart_putc('µ');
      de:	85 eb       	ldi	r24, 0xB5	; 181
      e0:	01 c0       	rjmp	.+2      	; 0xe4 <lcd_data+0x2e>
			break;
		case 244:	//Omega
			break;
		default:
			uart_putc(temp1);
      e2:	81 2f       	mov	r24, r17
      e4:	e7 dc       	rcall	.-1586   	; 0xfffffab4 <__eeprom_end+0xff7ef954>
	}
}
      e6:	1f 91       	pop	r17
      e8:	08 95       	ret

000000ea <uart_newline>:
   _delay_ms(5);
   uart_newline();
}

void uart_newline(void) {
	uart_putc('\r');
      ea:	8d e0       	ldi	r24, 0x0D	; 13
      ec:	e3 dc       	rcall	.-1594   	; 0xfffffab4 <__eeprom_end+0xff7ef954>
    uart_putc('\n');
      ee:	8a e0       	ldi	r24, 0x0A	; 10
      f0:	e1 dc       	rcall	.-1598   	; 0xfffffab4 <__eeprom_end+0xff7ef954>
}
      f2:	08 95       	ret

000000f4 <lcd_command>:
}
 
// sendet einen Befehl an das LCD
 
void lcd_command(unsigned char temp1)
{
      f4:	1f 93       	push	r17
      f6:	18 2f       	mov	r17, r24
	LCD_PORT &= ~(1<<LCD_RS);        // RS auf 0 setzen
      f8:	94 98       	cbi	0x12, 4	; 18
	lcd_send(temp1);
      fa:	b8 df       	rcall	.-144    	; 0x6c <lcd_send>
	if((temp1 == 0x80) || (temp1 == 0xC0)) {
      fc:	10 38       	cpi	r17, 0x80	; 128
      fe:	11 f0       	breq	.+4      	; 0x104 <lcd_command+0x10>
     100:	10 3c       	cpi	r17, 0xC0	; 192
     102:	09 f4       	brne	.+2      	; 0x106 <lcd_command+0x12>
		uart_newline();
     104:	f2 df       	rcall	.-28     	; 0xea <uart_newline>
	}
}
     106:	1f 91       	pop	r17
     108:	08 95       	ret

0000010a <lcd_clear>:
 
// Sendet den Befehl zur Löschung des Displays
 
void lcd_clear(void)
{
   lcd_command(CLEAR_DISPLAY);
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	f3 df       	rcall	.-26     	; 0xf4 <lcd_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     10e:	81 ee       	ldi	r24, 0xE1	; 225
     110:	94 e0       	ldi	r25, 0x04	; 4
     112:	01 97       	sbiw	r24, 0x01	; 1
     114:	f1 f7       	brne	.-4      	; 0x112 <lcd_clear+0x8>
     116:	00 c0       	rjmp	.+0      	; 0x118 <lcd_clear+0xe>
     118:	00 00       	nop
   _delay_ms(5);
   uart_newline();
     11a:	e7 df       	rcall	.-50     	; 0xea <uart_newline>
}
     11c:	08 95       	ret

0000011e <lcd_init>:
// Initialisierung: 
// Muss ganz am Anfang des Programms aufgerufen werden.
 
void lcd_init(void)
{
	LCD_DDR = LCD_DDR | 0x0F | (1<<LCD_RS) | (1<<LCD_EN1);   // Port auf Ausgang schalten
     11e:	81 b3       	in	r24, 0x11	; 17
     120:	8f 63       	ori	r24, 0x3F	; 63
     122:	81 bb       	out	0x11, r24	; 17
     124:	8b e4       	ldi	r24, 0x4B	; 75
     126:	9d e1       	ldi	r25, 0x1D	; 29
     128:	01 97       	sbiw	r24, 0x01	; 1
     12a:	f1 f7       	brne	.-4      	; 0x128 <lcd_init+0xa>
     12c:	00 c0       	rjmp	.+0      	; 0x12e <lcd_init+0x10>
     12e:	00 00       	nop
	// muss 3mal hintereinander gesendet werden zur Initialisierung
	_delay_ms(30);
	LCD_PORT = (LCD_PORT & 0xF0 & ~(1<<LCD_RS)) | 0x03;
     130:	82 b3       	in	r24, 0x12	; 18
     132:	80 7e       	andi	r24, 0xE0	; 224
     134:	83 60       	ori	r24, 0x03	; 3
     136:	82 bb       	out	0x12, r24	; 18
	lcd_enable();
     138:	92 df       	rcall	.-220    	; 0x5e <lcd_enable>
     13a:	81 ee       	ldi	r24, 0xE1	; 225
     13c:	94 e0       	ldi	r25, 0x04	; 4
     13e:	01 97       	sbiw	r24, 0x01	; 1
     140:	f1 f7       	brne	.-4      	; 0x13e <lcd_init+0x20>
     142:	00 c0       	rjmp	.+0      	; 0x144 <lcd_init+0x26>
     144:	00 00       	nop

	_delay_ms(5);
	lcd_enable();
     146:	8b df       	rcall	.-234    	; 0x5e <lcd_enable>
     148:	89 ef       	ldi	r24, 0xF9	; 249
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	01 97       	sbiw	r24, 0x01	; 1
     14e:	f1 f7       	brne	.-4      	; 0x14c <lcd_init+0x2e>
     150:	00 c0       	rjmp	.+0      	; 0x152 <lcd_init+0x34>
     152:	00 00       	nop

	_delay_ms(1);
	lcd_enable();
     154:	84 df       	rcall	.-248    	; 0x5e <lcd_enable>
     156:	89 ef       	ldi	r24, 0xF9	; 249
     158:	90 e0       	ldi	r25, 0x00	; 0
     15a:	01 97       	sbiw	r24, 0x01	; 1
     15c:	f1 f7       	brne	.-4      	; 0x15a <lcd_init+0x3c>
     15e:	00 c0       	rjmp	.+0      	; 0x160 <lcd_init+0x42>
     160:	00 00       	nop
	_delay_ms(1);
	LCD_PORT = (LCD_PORT & 0xF0 & ~(1<<LCD_RS)) | 0x02;
     162:	82 b3       	in	r24, 0x12	; 18
     164:	80 7e       	andi	r24, 0xE0	; 224
     166:	82 60       	ori	r24, 0x02	; 2
     168:	82 bb       	out	0x12, r24	; 18
     16a:	89 ef       	ldi	r24, 0xF9	; 249
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	01 97       	sbiw	r24, 0x01	; 1
     170:	f1 f7       	brne	.-4      	; 0x16e <lcd_init+0x50>
     172:	00 c0       	rjmp	.+0      	; 0x174 <lcd_init+0x56>
     174:	00 00       	nop
	_delay_ms(1);
	lcd_enable();
     176:	73 df       	rcall	.-282    	; 0x5e <lcd_enable>
     178:	89 ef       	ldi	r24, 0xF9	; 249
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	01 97       	sbiw	r24, 0x01	; 1
     17e:	f1 f7       	brne	.-4      	; 0x17c <lcd_init+0x5e>
     180:	00 c0       	rjmp	.+0      	; 0x182 <lcd_init+0x64>
     182:	00 00       	nop
	_delay_ms(1);

	// 4Bit / 2 Zeilen / 5x7
	lcd_command(CMD_SetIFOptions | 0x08);
     184:	88 e2       	ldi	r24, 0x28	; 40
     186:	b6 df       	rcall	.-148    	; 0xf4 <lcd_command>

	// Display ein / Cursor aus / kein Blinken
	lcd_command(CMD_SetDisplayAndCursor | 0x04);
     188:	8c e0       	ldi	r24, 0x0C	; 12
     18a:	b4 df       	rcall	.-152    	; 0xf4 <lcd_command>

	// inkrement / kein Scrollen    
	lcd_command(CMD_SetEntryMode | 0x02);	
     18c:	86 e0       	ldi	r24, 0x06	; 6
     18e:	b2 df       	rcall	.-156    	; 0xf4 <lcd_command>
	lcd_clear();
     190:	bc df       	rcall	.-136    	; 0x10a <lcd_clear>
}
     192:	08 95       	ret

00000194 <lcd_string>:
 
 
// Schreibt einen String auf das LCD
 
void lcd_string(char *data)
{
     194:	ef 92       	push	r14
     196:	ff 92       	push	r15
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	e8 2e       	mov	r14, r24
     19e:	e7 01       	movw	r28, r14
     1a0:	7e 01       	movw	r14, r28
     1a2:	f9 2e       	mov	r15, r25
     1a4:	e7 01       	movw	r28, r14
    while(*data) {
     1a6:	01 c0       	rjmp	.+2      	; 0x1aa <lcd_string+0x16>
        lcd_data(*data);
     1a8:	86 df       	rcall	.-244    	; 0xb6 <lcd_data>
 
// Schreibt einen String auf das LCD
 
void lcd_string(char *data)
{
    while(*data) {
     1aa:	89 91       	ld	r24, Y+
     1ac:	88 23       	and	r24, r24
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <lcd_string+0x14>
        lcd_data(*data);
        data++;
    }
}
     1b0:	df 91       	pop	r29
     1b2:	cf 91       	pop	r28
     1b4:	ff 90       	pop	r15
     1b6:	ef 90       	pop	r14
     1b8:	08 95       	ret

000001ba <lcd_eep_string>:

//String aus EEPROM laden und an LCD senden
void lcd_eep_string(const unsigned char *data)
{	
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	ec 01       	movw	r28, r24
	unsigned char c;
    while(1) {
		c = eeprom_read_byte(data);
     1c0:	ce 01       	movw	r24, r28
     1c2:	43 dd       	rcall	.-1402   	; 0xfffffc4a <__eeprom_end+0xff7efaea>
		if((c==0) || (c==128)) return;
     1c4:	88 23       	and	r24, r24
     1c6:	29 f0       	breq	.+10     	; 0x1d2 <lcd_eep_string+0x18>
     1c8:	80 38       	cpi	r24, 0x80	; 128
     1ca:	19 f0       	breq	.+6      	; 0x1d2 <lcd_eep_string+0x18>
        lcd_data(c);
     1cc:	74 df       	rcall	.-280    	; 0xb6 <lcd_data>
        data++;
     1ce:	21 96       	adiw	r28, 0x01	; 1
    }
     1d0:	f7 cf       	rjmp	.-18     	; 0x1c0 <lcd_eep_string+0x6>
}
     1d2:	df 91       	pop	r29
     1d4:	cf 91       	pop	r28
     1d6:	08 95       	ret

000001d8 <ReadADC>:


unsigned int ReadADC(uint8_t mux) {
	//ADC-Wert des angegebenen Kanals auslesen und als unsigned int zurückgegen
	unsigned int adcx = 0;
	ADMUX = mux | (1<<REFS0);
     1d8:	80 64       	ori	r24, 0x40	; 64
     1da:	87 b9       	out	0x07, r24	; 7
     1dc:	44 e1       	ldi	r20, 0x14	; 20
#endif


unsigned int ReadADC(uint8_t mux) {
	//ADC-Wert des angegebenen Kanals auslesen und als unsigned int zurückgegen
	unsigned int adcx = 0;
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	90 e0       	ldi	r25, 0x00	; 0
	ADMUX = mux | (1<<REFS0);
	for(uint8_t j=0;j<20;j++) {	//20 Messungen; für bessere Genauigkeit
		ADCSRA |= (1<<ADSC);
     1e2:	36 9a       	sbi	0x06, 6	; 6
		while (ADCSRA&(1<<ADSC));
     1e4:	36 99       	sbic	0x06, 6	; 6
     1e6:	fe cf       	rjmp	.-4      	; 0x1e4 <ReadADC+0xc>
		adcx += ADCW;
     1e8:	24 b1       	in	r18, 0x04	; 4
     1ea:	35 b1       	in	r19, 0x05	; 5
     1ec:	82 0f       	add	r24, r18
     1ee:	93 1f       	adc	r25, r19
     1f0:	41 50       	subi	r20, 0x01	; 1

unsigned int ReadADC(uint8_t mux) {
	//ADC-Wert des angegebenen Kanals auslesen und als unsigned int zurückgegen
	unsigned int adcx = 0;
	ADMUX = mux | (1<<REFS0);
	for(uint8_t j=0;j<20;j++) {	//20 Messungen; für bessere Genauigkeit
     1f2:	b9 f7       	brne	.-18     	; 0x1e2 <ReadADC+0xa>
		ADCSRA |= (1<<ADSC);
		while (ADCSRA&(1<<ADSC));
		adcx += ADCW;
	}
	adcx /= 20;
     1f4:	64 e1       	ldi	r22, 0x14	; 20
     1f6:	70 e0       	ldi	r23, 0x00	; 0
     1f8:	9c dc       	rcall	.-1736   	; 0xfffffb32 <__eeprom_end+0xff7ef9d2>
	return adcx;
}
     1fa:	cb 01       	movw	r24, r22
     1fc:	08 95       	ret

000001fe <DischargePin>:
		Parameter:
		PinToDischarge: zu entladender Pin
		DischargeDirection: 0 = gegen Masse (N-Kanal-FET), 1= gegen Plus(P-Kanal-FET)
	*/
	uint8_t tmpval;
	tmpval = (PinToDischarge * 2);		//nötig wegen der Anordnung der Widerstände
     1fe:	88 0f       	add	r24, r24

	if(DischargeDirection) R_PORT |= (1<<tmpval);			//R_L aus
     200:	66 23       	and	r22, r22
     202:	59 f0       	breq	.+22     	; 0x21a <DischargePin+0x1c>
     204:	98 b3       	in	r25, 0x18	; 24
     206:	21 e0       	ldi	r18, 0x01	; 1
     208:	30 e0       	ldi	r19, 0x00	; 0
     20a:	08 2e       	mov	r0, r24
     20c:	02 c0       	rjmp	.+4      	; 0x212 <DischargePin+0x14>
     20e:	22 0f       	add	r18, r18
     210:	33 1f       	adc	r19, r19
     212:	0a 94       	dec	r0
     214:	e2 f7       	brpl	.-8      	; 0x20e <DischargePin+0x10>
     216:	92 2b       	or	r25, r18
     218:	98 bb       	out	0x18, r25	; 24
	R_DDR |= (1<<tmpval);			//Pin auf Ausgang und über R_L auf Masse
     21a:	97 b3       	in	r25, 0x17	; 23
     21c:	21 e0       	ldi	r18, 0x01	; 1
     21e:	30 e0       	ldi	r19, 0x00	; 0
     220:	02 c0       	rjmp	.+4      	; 0x226 <DischargePin+0x28>
     222:	22 0f       	add	r18, r18
     224:	33 1f       	adc	r19, r19
     226:	8a 95       	dec	r24
     228:	e2 f7       	brpl	.-8      	; 0x222 <DischargePin+0x24>
     22a:	92 2b       	or	r25, r18
     22c:	97 bb       	out	0x17, r25	; 23
     22e:	83 ec       	ldi	r24, 0xC3	; 195
     230:	99 e0       	ldi	r25, 0x09	; 9
     232:	01 97       	sbiw	r24, 0x01	; 1
     234:	f1 f7       	brne	.-4      	; 0x232 <DischargePin+0x34>
     236:	00 c0       	rjmp	.+0      	; 0x238 <DischargePin+0x3a>
     238:	00 00       	nop
	_delay_ms(10);
	R_DDR &= ~(1<<tmpval);			//Pin wieder auf Eingang
     23a:	87 b3       	in	r24, 0x17	; 23
     23c:	20 95       	com	r18
     23e:	82 23       	and	r24, r18
     240:	87 bb       	out	0x17, r24	; 23
	if(DischargeDirection) R_PORT &= ~(1<<tmpval);			//R_L aus
     242:	66 23       	and	r22, r22
     244:	19 f0       	breq	.+6      	; 0x24c <DischargePin+0x4e>
     246:	88 b3       	in	r24, 0x18	; 24
     248:	82 23       	and	r24, r18
     24a:	88 bb       	out	0x18, r24	; 24
     24c:	08 95       	ret

0000024e <ReadCapacity>:
	R_DDR = 0;
	R_PORT = 0;
}

#ifdef UseM8	//Kapazitätsmessung nur auf Mega8 verfügbar
void ReadCapacity(uint8_t HighPin, uint8_t LowPin) {
     24e:	8f 92       	push	r8
     250:	9f 92       	push	r9
     252:	af 92       	push	r10
     254:	bf 92       	push	r11
     256:	cf 92       	push	r12
     258:	df 92       	push	r13
     25a:	ef 92       	push	r14
     25c:	ff 92       	push	r15
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	df 93       	push	r29
     264:	cf 93       	push	r28
     266:	0f 92       	push	r0
     268:	cd b7       	in	r28, 0x3d	; 61
     26a:	de b7       	in	r29, 0x3e	; 62
     26c:	18 2f       	mov	r17, r24
     26e:	b6 2e       	mov	r11, r22
	//Test auf Kondensator (auch nur auf ATMega8 möglich)
	if(PartFound == PART_CAPACITOR) goto end;	//Schon einen Kondensator gefunden
     270:	80 91 68 00 	lds	r24, 0x0068
     274:	87 30       	cpi	r24, 0x07	; 7
     276:	09 f4       	brne	.+2      	; 0x27a <ReadCapacity+0x2c>
     278:	b9 c1       	rjmp	.+882    	; 0x5ec <__stack+0x18d>
	unsigned long gcval = 0;
	unsigned int tmpint = 0;
	uint8_t extcnt = 0;
	uint8_t tmpx = 0;
	
	tmpval2 = (2<<(2*HighPin));	//R_H
     27a:	21 2f       	mov	r18, r17
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	22 0f       	add	r18, r18
     280:	33 1f       	adc	r19, r19
     282:	82 e0       	ldi	r24, 0x02	; 2
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	02 2e       	mov	r0, r18
     288:	02 c0       	rjmp	.+4      	; 0x28e <ReadCapacity+0x40>
     28a:	88 0f       	add	r24, r24
     28c:	99 1f       	adc	r25, r25
     28e:	0a 94       	dec	r0
     290:	e2 f7       	brpl	.-8      	; 0x28a <ReadCapacity+0x3c>
     292:	80 93 78 00 	sts	0x0078, r24
	tmpval = (1<<(2*HighPin));	//R_L
     296:	41 e0       	ldi	r20, 0x01	; 1
     298:	50 e0       	ldi	r21, 0x00	; 0
     29a:	ba 01       	movw	r22, r20
     29c:	02 c0       	rjmp	.+4      	; 0x2a2 <ReadCapacity+0x54>
     29e:	66 0f       	add	r22, r22
     2a0:	77 1f       	adc	r23, r23
     2a2:	2a 95       	dec	r18
     2a4:	e2 f7       	brpl	.-8      	; 0x29e <ReadCapacity+0x50>
     2a6:	a6 2e       	mov	r10, r22
     2a8:	60 93 6a 00 	sts	0x006A, r22
	ADC_PORT = TXD_VAL;
     2ac:	15 ba       	out	0x15, r1	; 21
	R_PORT = 0;
     2ae:	18 ba       	out	0x18, r1	; 24
	R_DDR = 0;
     2b0:	17 ba       	out	0x17, r1	; 23
	ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin fest auf Masse
     2b2:	0b 2c       	mov	r0, r11
     2b4:	02 c0       	rjmp	.+4      	; 0x2ba <ReadCapacity+0x6c>
     2b6:	44 0f       	add	r20, r20
     2b8:	55 1f       	adc	r21, r21
     2ba:	0a 94       	dec	r0
     2bc:	e2 f7       	brpl	.-8      	; 0x2b6 <ReadCapacity+0x68>
     2be:	04 2f       	mov	r16, r20
     2c0:	08 60       	ori	r16, 0x08	; 8
     2c2:	04 bb       	out	0x14, r16	; 20
	R_DDR = tmpval2;		//HighPin über R_H auf Masse
     2c4:	87 bb       	out	0x17, r24	; 23
     2c6:	81 ee       	ldi	r24, 0xE1	; 225
     2c8:	94 e0       	ldi	r25, 0x04	; 4
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	f1 f7       	brne	.-4      	; 0x2ca <ReadCapacity+0x7c>
     2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <ReadCapacity+0x82>
     2d0:	00 00       	nop
	_delay_ms(5);
	adcv[0] = ReadADC(HighPin);
     2d2:	81 2f       	mov	r24, r17
     2d4:	81 df       	rcall	.-254    	; 0x1d8 <ReadADC>
     2d6:	90 93 85 00 	sts	0x0085, r25
     2da:	80 93 84 00 	sts	0x0084, r24
	DischargePin(HighPin,1);
     2de:	81 2f       	mov	r24, r17
     2e0:	61 e0       	ldi	r22, 0x01	; 1
     2e2:	8d df       	rcall	.-230    	; 0x1fe <DischargePin>
	adcv[2] = ReadADC(HighPin);
     2e4:	81 2f       	mov	r24, r17
     2e6:	78 df       	rcall	.-272    	; 0x1d8 <ReadADC>
     2e8:	90 93 89 00 	sts	0x0089, r25
     2ec:	80 93 88 00 	sts	0x0088, r24
     2f0:	e1 ee       	ldi	r30, 0xE1	; 225
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	31 97       	sbiw	r30, 0x01	; 1
     2f6:	f1 f7       	brne	.-4      	; 0x2f4 <ReadCapacity+0xa6>
     2f8:	00 c0       	rjmp	.+0      	; 0x2fa <ReadCapacity+0xac>
     2fa:	00 00       	nop
	_delay_ms(5);
	adcv[1] = ReadADC(HighPin);
     2fc:	81 2f       	mov	r24, r17
     2fe:	6c df       	rcall	.-296    	; 0x1d8 <ReadADC>
     300:	90 93 87 00 	sts	0x0087, r25
     304:	80 93 86 00 	sts	0x0086, r24
	wdt_reset();
     308:	a8 95       	wdr
	if((adcv[1] > (adcv[0] + 1)) || (adcv[2] > (adcv[0] + 1))) {	//Spannung ist gestiegen
     30a:	20 91 84 00 	lds	r18, 0x0084
     30e:	30 91 85 00 	lds	r19, 0x0085
     312:	2f 5f       	subi	r18, 0xFF	; 255
     314:	3f 4f       	sbci	r19, 0xFF	; 255
     316:	28 17       	cp	r18, r24
     318:	39 07       	cpc	r19, r25
     31a:	40 f0       	brcs	.+16     	; 0x32c <ReadCapacity+0xde>
     31c:	80 91 88 00 	lds	r24, 0x0088
     320:	90 91 89 00 	lds	r25, 0x0089
     324:	28 17       	cp	r18, r24
     326:	39 07       	cpc	r19, r25
     328:	08 f0       	brcs	.+2      	; 0x32c <ReadCapacity+0xde>
     32a:	60 c1       	rjmp	.+704    	; 0x5ec <__stack+0x18d>
		R_DDR = tmpval;			//High-Pin über R_L auf Masse
     32c:	80 91 6a 00 	lds	r24, 0x006A
     330:	87 bb       	out	0x17, r24	; 23
void ReadCapacity(uint8_t HighPin, uint8_t LowPin) {
	//Test auf Kondensator (auch nur auf ATMega8 möglich)
	if(PartFound == PART_CAPACITOR) goto end;	//Schon einen Kondensator gefunden
	unsigned long gcval = 0;
	unsigned int tmpint = 0;
	uint8_t extcnt = 0;
     332:	20 e0       	ldi	r18, 0x00	; 0
#ifdef UseM8	//Kapazitätsmessung nur auf Mega8 verfügbar
void ReadCapacity(uint8_t HighPin, uint8_t LowPin) {
	//Test auf Kondensator (auch nur auf ATMega8 möglich)
	if(PartFound == PART_CAPACITOR) goto end;	//Schon einen Kondensator gefunden
	unsigned long gcval = 0;
	unsigned int tmpint = 0;
     334:	cc 24       	eor	r12, r12
     336:	dd 24       	eor	r13, r13
	_delay_ms(5);
	adcv[1] = ReadADC(HighPin);
	wdt_reset();
	if((adcv[1] > (adcv[0] + 1)) || (adcv[2] > (adcv[0] + 1))) {	//Spannung ist gestiegen
		R_DDR = tmpval;			//High-Pin über R_L auf Masse
		while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     338:	0a c0       	rjmp	.+20     	; 0x34e <ReadCapacity+0x100>
			wdt_reset();
     33a:	a8 95       	wdr
			tmpint++;
     33c:	08 94       	sec
     33e:	c1 1c       	adc	r12, r1
     340:	d1 1c       	adc	r13, r1
			if(tmpint==0) {
     342:	c1 14       	cp	r12, r1
     344:	d1 04       	cpc	r13, r1
     346:	19 f4       	brne	.+6      	; 0x34e <ReadCapacity+0x100>
				extcnt++;
     348:	2f 5f       	subi	r18, 0xFF	; 255
				if(extcnt == 30) break; //Timeout für Entladung
     34a:	2e 31       	cpi	r18, 0x1E	; 30
     34c:	59 f0       	breq	.+22     	; 0x364 <ReadCapacity+0x116>
	_delay_ms(5);
	adcv[1] = ReadADC(HighPin);
	wdt_reset();
	if((adcv[1] > (adcv[0] + 1)) || (adcv[2] > (adcv[0] + 1))) {	//Spannung ist gestiegen
		R_DDR = tmpval;			//High-Pin über R_L auf Masse
		while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     34e:	81 2f       	mov	r24, r17
     350:	29 83       	std	Y+1, r18	; 0x01
     352:	42 df       	rcall	.-380    	; 0x1d8 <ReadADC>
     354:	7c 01       	movw	r14, r24
     356:	8b 2d       	mov	r24, r11
     358:	3f df       	rcall	.-386    	; 0x1d8 <ReadADC>
     35a:	0a 96       	adiw	r24, 0x0a	; 10
     35c:	29 81       	ldd	r18, Y+1	; 0x01
     35e:	8e 15       	cp	r24, r14
     360:	9f 05       	cpc	r25, r15
     362:	58 f3       	brcs	.-42     	; 0x33a <ReadCapacity+0xec>
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		tmpint = 0;
		extcnt = 0;
		R_PORT = tmpval;			//High-Pin über R_L auf Plus
     364:	80 91 6a 00 	lds	r24, 0x006A
     368:	88 bb       	out	0x18, r24	; 24
     36a:	81 ee       	ldi	r24, 0xE1	; 225
     36c:	94 e0       	ldi	r25, 0x04	; 4
     36e:	01 97       	sbiw	r24, 0x01	; 1
     370:	f1 f7       	brne	.-4      	; 0x36e <ReadCapacity+0x120>
     372:	00 c0       	rjmp	.+0      	; 0x374 <ReadCapacity+0x126>
     374:	00 00       	nop
		_delay_ms(5);
		adcv[2] = ReadADC(HighPin);
     376:	81 2f       	mov	r24, r17
     378:	2f df       	rcall	.-418    	; 0x1d8 <ReadADC>
     37a:	90 93 89 00 	sts	0x0089, r25
     37e:	80 93 88 00 	sts	0x0088, r24
     382:	ef e1       	ldi	r30, 0x1F	; 31
     384:	fe e4       	ldi	r31, 0x4E	; 78
     386:	31 97       	sbiw	r30, 0x01	; 1
     388:	f1 f7       	brne	.-4      	; 0x386 <ReadCapacity+0x138>
     38a:	00 c0       	rjmp	.+0      	; 0x38c <ReadCapacity+0x13e>
     38c:	00 00       	nop
		_delay_ms(80);
		adcv[3] = ReadADC(HighPin);
     38e:	81 2f       	mov	r24, r17
     390:	23 df       	rcall	.-442    	; 0x1d8 <ReadADC>
     392:	90 93 8b 00 	sts	0x008B, r25
     396:	80 93 8a 00 	sts	0x008A, r24
		if((adcv[3] < (adcv[2] + 3)) && (adcv[3] < 850)) goto end;	//Spannung ist nicht nennenswert gestiegen => Abbruch
     39a:	20 91 88 00 	lds	r18, 0x0088
     39e:	30 91 89 00 	lds	r19, 0x0089
     3a2:	2d 5f       	subi	r18, 0xFD	; 253
     3a4:	3f 4f       	sbci	r19, 0xFF	; 255
     3a6:	82 17       	cp	r24, r18
     3a8:	93 07       	cpc	r25, r19
     3aa:	28 f4       	brcc	.+10     	; 0x3b6 <ReadCapacity+0x168>
     3ac:	f3 e0       	ldi	r31, 0x03	; 3
     3ae:	82 35       	cpi	r24, 0x52	; 82
     3b0:	9f 07       	cpc	r25, r31
     3b2:	08 f4       	brcc	.+2      	; 0x3b6 <ReadCapacity+0x168>
     3b4:	1b c1       	rjmp	.+566    	; 0x5ec <__stack+0x18d>
		if((NumOfDiodes > 0) && (adcv[3] > 950) && (PartFound != PART_FET)) goto end; //höchstwahrscheinlich eine (oder mehrere) Diode(n) in Sperrrichtung, die sonst fälschlicherweise als Kondensator erkannt wird
     3b6:	20 91 66 00 	lds	r18, 0x0066
     3ba:	22 23       	and	r18, r18
     3bc:	49 f0       	breq	.+18     	; 0x3d0 <ReadCapacity+0x182>
     3be:	23 e0       	ldi	r18, 0x03	; 3
     3c0:	87 3b       	cpi	r24, 0xB7	; 183
     3c2:	92 07       	cpc	r25, r18
     3c4:	28 f0       	brcs	.+10     	; 0x3d0 <ReadCapacity+0x182>
     3c6:	80 91 68 00 	lds	r24, 0x0068
     3ca:	83 30       	cpi	r24, 0x03	; 3
     3cc:	09 f0       	breq	.+2      	; 0x3d0 <ReadCapacity+0x182>
     3ce:	0e c1       	rjmp	.+540    	; 0x5ec <__stack+0x18d>
		R_PORT = 0;
     3d0:	18 ba       	out	0x18, r1	; 24
				extcnt++;
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		tmpint = 0;
		extcnt = 0;
     3d2:	20 e0       	ldi	r18, 0x00	; 0
			if(tmpint==0) {
				extcnt++;
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		tmpint = 0;
     3d4:	cc 24       	eor	r12, r12
     3d6:	dd 24       	eor	r13, r13
		_delay_ms(80);
		adcv[3] = ReadADC(HighPin);
		if((adcv[3] < (adcv[2] + 3)) && (adcv[3] < 850)) goto end;	//Spannung ist nicht nennenswert gestiegen => Abbruch
		if((NumOfDiodes > 0) && (adcv[3] > 950) && (PartFound != PART_FET)) goto end; //höchstwahrscheinlich eine (oder mehrere) Diode(n) in Sperrrichtung, die sonst fälschlicherweise als Kondensator erkannt wird
		R_PORT = 0;
		while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     3d8:	0a c0       	rjmp	.+20     	; 0x3ee <ReadCapacity+0x1a0>
			wdt_reset();
     3da:	a8 95       	wdr
			tmpint++;
     3dc:	08 94       	sec
     3de:	c1 1c       	adc	r12, r1
     3e0:	d1 1c       	adc	r13, r1
			if(tmpint==0) {
     3e2:	c1 14       	cp	r12, r1
     3e4:	d1 04       	cpc	r13, r1
     3e6:	19 f4       	brne	.+6      	; 0x3ee <ReadCapacity+0x1a0>
				extcnt++;
     3e8:	2f 5f       	subi	r18, 0xFF	; 255
				if(extcnt == 30) break; //Timeout für Entladung
     3ea:	2e 31       	cpi	r18, 0x1E	; 30
     3ec:	59 f0       	breq	.+22     	; 0x404 <ReadCapacity+0x1b6>
		_delay_ms(80);
		adcv[3] = ReadADC(HighPin);
		if((adcv[3] < (adcv[2] + 3)) && (adcv[3] < 850)) goto end;	//Spannung ist nicht nennenswert gestiegen => Abbruch
		if((NumOfDiodes > 0) && (adcv[3] > 950) && (PartFound != PART_FET)) goto end; //höchstwahrscheinlich eine (oder mehrere) Diode(n) in Sperrrichtung, die sonst fälschlicherweise als Kondensator erkannt wird
		R_PORT = 0;
		while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     3ee:	81 2f       	mov	r24, r17
     3f0:	29 83       	std	Y+1, r18	; 0x01
     3f2:	f2 de       	rcall	.-540    	; 0x1d8 <ReadADC>
     3f4:	7c 01       	movw	r14, r24
     3f6:	8b 2d       	mov	r24, r11
     3f8:	ef de       	rcall	.-546    	; 0x1d8 <ReadADC>
     3fa:	0a 96       	adiw	r24, 0x0a	; 10
     3fc:	29 81       	ldd	r18, Y+1	; 0x01
     3fe:	8e 15       	cp	r24, r14
     400:	9f 05       	cpc	r25, r15
     402:	58 f3       	brcs	.-42     	; 0x3da <ReadCapacity+0x18c>
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		tmpint = 0;
		extcnt = 0;
		ADC_DDR = 7 | (1<<TxD);					//alle Pins auf Ausgang und aus Masse
     404:	8f e0       	ldi	r24, 0x0F	; 15
     406:	84 bb       	out	0x14, r24	; 20
		R_PORT = tmpval;  	   			// HighPin über R_L auf Plus
     408:	80 91 6a 00 	lds	r24, 0x006A
     40c:	88 bb       	out	0x18, r24	; 24
		tmpval=(1<<HighPin);
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	01 2e       	mov	r0, r17
     414:	02 c0       	rjmp	.+4      	; 0x41a <ReadCapacity+0x1cc>
     416:	88 0f       	add	r24, r24
     418:	99 1f       	adc	r25, r25
     41a:	0a 94       	dec	r0
     41c:	e2 f7       	brpl	.-8      	; 0x416 <ReadCapacity+0x1c8>
     41e:	80 93 6a 00 	sts	0x006A, r24
     422:	e3 ef       	ldi	r30, 0xF3	; 243
     424:	f1 e0       	ldi	r31, 0x01	; 1
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	f1 f7       	brne	.-4      	; 0x426 <ReadCapacity+0x1d8>
     42a:	00 c0       	rjmp	.+0      	; 0x42c <ReadCapacity+0x1de>
     42c:	00 00       	nop
		_delay_ms(2);
		ADC_DDR = (1<<LowPin) | (1<<TxD);          // Kondensator über R_L langsam laden
     42e:	04 bb       	out	0x14, r16	; 20
				extcnt++;
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		tmpint = 0;
		extcnt = 0;
     430:	60 e0       	ldi	r22, 0x00	; 0
			if(tmpint==0) {
				extcnt++;
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		tmpint = 0;
     432:	ee 24       	eor	r14, r14
     434:	ff 24       	eor	r15, r15
		ADC_DDR = 7 | (1<<TxD);					//alle Pins auf Ausgang und aus Masse
		R_PORT = tmpval;  	   			// HighPin über R_L auf Plus
		tmpval=(1<<HighPin);
		_delay_ms(2);
		ADC_DDR = (1<<LowPin) | (1<<TxD);          // Kondensator über R_L langsam laden
		while (!(ADC_PIN & tmpval)) {  // Warten, bis HighPin auf High geht; Schleife dauert 7 Zyklen
     436:	0b c0       	rjmp	.+22     	; 0x44e <ReadCapacity+0x200>
			wdt_reset();
     438:	a8 95       	wdr
			tmpint++;
     43a:	08 94       	sec
     43c:	e1 1c       	adc	r14, r1
     43e:	f1 1c       	adc	r15, r1
			if(tmpint==0) {
     440:	e1 14       	cp	r14, r1
     442:	f1 04       	cpc	r15, r1
     444:	21 f4       	brne	.+8      	; 0x44e <ReadCapacity+0x200>
				extcnt++;
     446:	6f 5f       	subi	r22, 0xFF	; 255
				if(extcnt == 30) break; //Timeout für Ladung
     448:	6e 31       	cpi	r22, 0x1E	; 30
     44a:	09 f4       	brne	.+2      	; 0x44e <ReadCapacity+0x200>
     44c:	56 c0       	rjmp	.+172    	; 0x4fa <__stack+0x9b>
		ADC_DDR = 7 | (1<<TxD);					//alle Pins auf Ausgang und aus Masse
		R_PORT = tmpval;  	   			// HighPin über R_L auf Plus
		tmpval=(1<<HighPin);
		_delay_ms(2);
		ADC_DDR = (1<<LowPin) | (1<<TxD);          // Kondensator über R_L langsam laden
		while (!(ADC_PIN & tmpval)) {  // Warten, bis HighPin auf High geht; Schleife dauert 7 Zyklen
     44e:	93 b3       	in	r25, 0x13	; 19
     450:	98 23       	and	r25, r24
     452:	91 f3       	breq	.-28     	; 0x438 <ReadCapacity+0x1ea>
     454:	c6 2e       	mov	r12, r22
			if(tmpint==0) {
				extcnt++;
				if(extcnt == 30) break; //Timeout für Ladung
			}
		}
		if((extcnt == 0) && (tmpint<256)) {	//Niedrige Kapazität
     456:	66 23       	and	r22, r22
     458:	09 f0       	breq	.+2      	; 0x45c <ReadCapacity+0x20e>
     45a:	4f c0       	rjmp	.+158    	; 0x4fa <__stack+0x9b>
     45c:	ff ef       	ldi	r31, 0xFF	; 255
     45e:	ef 16       	cp	r14, r31
     460:	f1 04       	cpc	r15, r1
     462:	11 f0       	breq	.+4      	; 0x468 <__stack+0x9>
     464:	08 f0       	brcs	.+2      	; 0x468 <__stack+0x9>
     466:	49 c0       	rjmp	.+146    	; 0x4fa <__stack+0x9b>
			ADC_DDR = (1<<LowPin) | (1<<TxD);
     468:	04 bb       	out	0x14, r16	; 20
			//mit R_H erneut messen
			R_PORT = 0;
     46a:	18 ba       	out	0x18, r1	; 24
			tmpint = 0;
			extcnt = 0;
     46c:	20 e0       	ldi	r18, 0x00	; 0
		}
		if((extcnt == 0) && (tmpint<256)) {	//Niedrige Kapazität
			ADC_DDR = (1<<LowPin) | (1<<TxD);
			//mit R_H erneut messen
			R_PORT = 0;
			tmpint = 0;
     46e:	88 24       	eor	r8, r8
     470:	99 24       	eor	r9, r9
			extcnt = 0;
			while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     472:	0a c0       	rjmp	.+20     	; 0x488 <__stack+0x29>
				wdt_reset();
     474:	a8 95       	wdr
				tmpint++;
     476:	08 94       	sec
     478:	81 1c       	adc	r8, r1
     47a:	91 1c       	adc	r9, r1
				if(tmpint==0) {
     47c:	81 14       	cp	r8, r1
     47e:	91 04       	cpc	r9, r1
     480:	19 f4       	brne	.+6      	; 0x488 <__stack+0x29>
					extcnt++;
     482:	2f 5f       	subi	r18, 0xFF	; 255
					if(extcnt == 30) break; //Timeout für Entladung
     484:	2e 31       	cpi	r18, 0x1E	; 30
     486:	59 f0       	breq	.+22     	; 0x49e <__stack+0x3f>
			ADC_DDR = (1<<LowPin) | (1<<TxD);
			//mit R_H erneut messen
			R_PORT = 0;
			tmpint = 0;
			extcnt = 0;
			while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     488:	81 2f       	mov	r24, r17
     48a:	29 83       	std	Y+1, r18	; 0x01
     48c:	a5 de       	rcall	.-694    	; 0x1d8 <ReadADC>
     48e:	7c 01       	movw	r14, r24
     490:	8b 2d       	mov	r24, r11
     492:	a2 de       	rcall	.-700    	; 0x1d8 <ReadADC>
     494:	0a 96       	adiw	r24, 0x0a	; 10
     496:	29 81       	ldd	r18, Y+1	; 0x01
     498:	8e 15       	cp	r24, r14
     49a:	9f 05       	cpc	r25, r15
     49c:	58 f3       	brcs	.-42     	; 0x474 <__stack+0x15>
					if(extcnt == 30) break; //Timeout für Entladung
				}
			}
			tmpint = 0;
			extcnt = 0;
			ADC_DDR = 7 | (1<<TxD);					//alle Pins auf Ausgang
     49e:	8f e0       	ldi	r24, 0x0F	; 15
     4a0:	84 bb       	out	0x14, r24	; 20
			ADC_PORT = TXD_VAL;					//alle Pins fest auf Masse
     4a2:	15 ba       	out	0x15, r1	; 21
			R_DDR = tmpval2;        		// HighPin über R_H auf Ausgang
     4a4:	80 91 78 00 	lds	r24, 0x0078
     4a8:	87 bb       	out	0x17, r24	; 23
			R_PORT = tmpval2;  	   			// HighPin über R_H auf Plus
     4aa:	88 bb       	out	0x18, r24	; 24
     4ac:	83 ef       	ldi	r24, 0xF3	; 243
     4ae:	91 e0       	ldi	r25, 0x01	; 1
     4b0:	01 97       	sbiw	r24, 0x01	; 1
     4b2:	f1 f7       	brne	.-4      	; 0x4b0 <__stack+0x51>
     4b4:	00 c0       	rjmp	.+0      	; 0x4b6 <__stack+0x57>
     4b6:	00 00       	nop
			_delay_ms(2);
			if(PartFound == PART_FET) {
     4b8:	80 91 68 00 	lds	r24, 0x0068
     4bc:	83 30       	cpi	r24, 0x03	; 3
     4be:	59 f4       	brne	.+22     	; 0x4d6 <__stack+0x77>
				ADC_DDR = (7 & ~tmpval) | (1<<TxD);          // Kondensator über R_H langsam laden, dabei freien Pin (Drain) für Gate-Kapazitäts-Messung auf Masse
     4c0:	80 91 6a 00 	lds	r24, 0x006A
     4c4:	80 95       	com	r24
     4c6:	87 70       	andi	r24, 0x07	; 7
     4c8:	88 60       	ori	r24, 0x08	; 8
     4ca:	84 bb       	out	0x14, r24	; 20
			} else {
				ADC_DDR = (1<<LowPin) | (1<<TxD);          // Kondensator über R_H langsam laden
			}
			while (!(ADC_PIN & tmpval)) {  // Warten, bis HighPin auf High geht; Schleife dauert 7 Zyklen
     4cc:	90 91 6a 00 	lds	r25, 0x006A
     4d0:	ee 24       	eor	r14, r14
     4d2:	ff 24       	eor	r15, r15
     4d4:	0e c0       	rjmp	.+28     	; 0x4f2 <__stack+0x93>
			R_PORT = tmpval2;  	   			// HighPin über R_H auf Plus
			_delay_ms(2);
			if(PartFound == PART_FET) {
				ADC_DDR = (7 & ~tmpval) | (1<<TxD);          // Kondensator über R_H langsam laden, dabei freien Pin (Drain) für Gate-Kapazitäts-Messung auf Masse
			} else {
				ADC_DDR = (1<<LowPin) | (1<<TxD);          // Kondensator über R_H langsam laden
     4d6:	04 bb       	out	0x14, r16	; 20
     4d8:	f9 cf       	rjmp	.-14     	; 0x4cc <__stack+0x6d>
			}
			while (!(ADC_PIN & tmpval)) {  // Warten, bis HighPin auf High geht; Schleife dauert 7 Zyklen
				wdt_reset();
     4da:	a8 95       	wdr
				tmpint++;
     4dc:	08 94       	sec
     4de:	e1 1c       	adc	r14, r1
     4e0:	f1 1c       	adc	r15, r1
				if(tmpint==0) {
     4e2:	e1 14       	cp	r14, r1
     4e4:	f1 04       	cpc	r15, r1
     4e6:	29 f4       	brne	.+10     	; 0x4f2 <__stack+0x93>
					extcnt++;
     4e8:	c3 94       	inc	r12
					if(extcnt == 30) break; //Timeout für Kapazitätsmessung
     4ea:	ec 2d       	mov	r30, r12
     4ec:	ee 31       	cpi	r30, 0x1E	; 30
     4ee:	09 f4       	brne	.+2      	; 0x4f2 <__stack+0x93>
     4f0:	90 c0       	rjmp	.+288    	; 0x612 <__stack+0x1b3>
			if(PartFound == PART_FET) {
				ADC_DDR = (7 & ~tmpval) | (1<<TxD);          // Kondensator über R_H langsam laden, dabei freien Pin (Drain) für Gate-Kapazitäts-Messung auf Masse
			} else {
				ADC_DDR = (1<<LowPin) | (1<<TxD);          // Kondensator über R_H langsam laden
			}
			while (!(ADC_PIN & tmpval)) {  // Warten, bis HighPin auf High geht; Schleife dauert 7 Zyklen
     4f2:	83 b3       	in	r24, 0x13	; 19
     4f4:	89 23       	and	r24, r25
     4f6:	89 f3       	breq	.-30     	; 0x4da <__stack+0x7b>
     4f8:	8c c0       	rjmp	.+280    	; 0x612 <__stack+0x1b3>
		if(tmpx) {
			gcval = eeprom_read_word(&H_CAPACITY_FACTOR);
			if((extcnt == 0) && (tmpint < 5)) goto end;	//Kapazität zu gering
			cv = 1;
		} else {
			gcval = eeprom_read_word(&L_CAPACITY_FACTOR);
     4fa:	8a e0       	ldi	r24, 0x0A	; 10
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	69 83       	std	Y+1, r22	; 0x01
     500:	ac db       	rcall	.-2216   	; 0xfffffc5a <__eeprom_end+0xff7efafa>
     502:	9c 01       	movw	r18, r24
     504:	40 e0       	ldi	r20, 0x00	; 0
     506:	50 e0       	ldi	r21, 0x00	; 0
			cv = 1000;
     508:	88 ee       	ldi	r24, 0xE8	; 232
     50a:	93 e0       	ldi	r25, 0x03	; 3
     50c:	a0 e0       	ldi	r26, 0x00	; 0
     50e:	b0 e0       	ldi	r27, 0x00	; 0
     510:	80 93 6b 00 	sts	0x006B, r24
     514:	90 93 6c 00 	sts	0x006C, r25
     518:	a0 93 6d 00 	sts	0x006D, r26
     51c:	b0 93 6e 00 	sts	0x006E, r27
     520:	69 81       	ldd	r22, Y+1	; 0x01
     522:	c6 2e       	mov	r12, r22
     524:	14 c0       	rjmp	.+40     	; 0x54e <__stack+0xef>
			}
			tmpx = 1;
		}
		if(tmpx) {
			gcval = eeprom_read_word(&H_CAPACITY_FACTOR);
			if((extcnt == 0) && (tmpint < 5)) goto end;	//Kapazität zu gering
     526:	f5 e0       	ldi	r31, 0x05	; 5
     528:	ef 16       	cp	r14, r31
     52a:	f1 04       	cpc	r15, r1
     52c:	08 f4       	brcc	.+2      	; 0x530 <__stack+0xd1>
     52e:	5e c0       	rjmp	.+188    	; 0x5ec <__stack+0x18d>
				}
			}
			tmpx = 1;
		}
		if(tmpx) {
			gcval = eeprom_read_word(&H_CAPACITY_FACTOR);
     530:	9c 01       	movw	r18, r24
     532:	40 e0       	ldi	r20, 0x00	; 0
     534:	50 e0       	ldi	r21, 0x00	; 0
			if((extcnt == 0) && (tmpint < 5)) goto end;	//Kapazität zu gering
			cv = 1;
     536:	81 e0       	ldi	r24, 0x01	; 1
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	a0 e0       	ldi	r26, 0x00	; 0
     53c:	b0 e0       	ldi	r27, 0x00	; 0
     53e:	80 93 6b 00 	sts	0x006B, r24
     542:	90 93 6c 00 	sts	0x006C, r25
     546:	a0 93 6d 00 	sts	0x006D, r26
     54a:	b0 93 6e 00 	sts	0x006E, r27
		} else {
			gcval = eeprom_read_word(&L_CAPACITY_FACTOR);
			cv = 1000;
		}

		gcval *= (unsigned long)(((unsigned long)extcnt * 65536) + (unsigned long)tmpint);	//Wert unrechnen und speichern
     54e:	6c 2d       	mov	r22, r12
     550:	70 e0       	ldi	r23, 0x00	; 0
     552:	80 e0       	ldi	r24, 0x00	; 0
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	cb 01       	movw	r24, r22
     558:	77 27       	eor	r23, r23
     55a:	66 27       	eor	r22, r22
     55c:	67 01       	movw	r12, r14
     55e:	ee 24       	eor	r14, r14
     560:	ff 24       	eor	r15, r15
     562:	6c 0d       	add	r22, r12
     564:	7d 1d       	adc	r23, r13
     566:	8e 1d       	adc	r24, r14
     568:	9f 1d       	adc	r25, r15
     56a:	c4 da       	rcall	.-2680   	; 0xfffffaf4 <__eeprom_end+0xff7ef994>
		gcval /= 100;
     56c:	24 e6       	ldi	r18, 0x64	; 100
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	40 e0       	ldi	r20, 0x00	; 0
     572:	50 e0       	ldi	r21, 0x00	; 0
     574:	f2 da       	rcall	.-2588   	; 0xfffffb5a <__eeprom_end+0xff7ef9fa>
		cv *= gcval;
     576:	60 91 6b 00 	lds	r22, 0x006B
     57a:	70 91 6c 00 	lds	r23, 0x006C
     57e:	80 91 6d 00 	lds	r24, 0x006D
     582:	90 91 6e 00 	lds	r25, 0x006E
     586:	b6 da       	rcall	.-2708   	; 0xfffffaf4 <__eeprom_end+0xff7ef994>
     588:	60 93 6b 00 	sts	0x006B, r22
     58c:	70 93 6c 00 	sts	0x006C, r23
     590:	80 93 6d 00 	sts	0x006D, r24
     594:	90 93 6e 00 	sts	0x006E, r25

		PartFound = PART_CAPACITOR;	//Kondensator gefunden
     598:	87 e0       	ldi	r24, 0x07	; 7
     59a:	80 93 68 00 	sts	0x0068, r24

		ca = HighPin;
     59e:	10 93 9b 00 	sts	0x009B, r17
		cb = LowPin;
     5a2:	b0 92 69 00 	sts	0x0069, r11
		//Kondensator wieder entladen
		tmpint = 0;
		extcnt = 0;
		R_DDR = (1<<(2*HighPin));			//High-Pin über R_L auf Masse
     5a6:	a7 ba       	out	0x17, r10	; 23
		R_PORT = 0;
     5a8:	18 ba       	out	0x18, r1	; 24

		ca = HighPin;
		cb = LowPin;
		//Kondensator wieder entladen
		tmpint = 0;
		extcnt = 0;
     5aa:	00 e0       	ldi	r16, 0x00	; 0
		PartFound = PART_CAPACITOR;	//Kondensator gefunden

		ca = HighPin;
		cb = LowPin;
		//Kondensator wieder entladen
		tmpint = 0;
     5ac:	cc 24       	eor	r12, r12
     5ae:	dd 24       	eor	r13, r13
		extcnt = 0;
		R_DDR = (1<<(2*HighPin));			//High-Pin über R_L auf Masse
		R_PORT = 0;
		while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     5b0:	0a c0       	rjmp	.+20     	; 0x5c6 <__stack+0x167>
			wdt_reset();
     5b2:	a8 95       	wdr
			tmpint++;
     5b4:	08 94       	sec
     5b6:	c1 1c       	adc	r12, r1
     5b8:	d1 1c       	adc	r13, r1
			if(tmpint==0) {
     5ba:	c1 14       	cp	r12, r1
     5bc:	d1 04       	cpc	r13, r1
     5be:	19 f4       	brne	.+6      	; 0x5c6 <__stack+0x167>
				extcnt++;
     5c0:	0f 5f       	subi	r16, 0xFF	; 255
				if(extcnt == 30) break; //Timeout für Entladung
     5c2:	0e 31       	cpi	r16, 0x1E	; 30
     5c4:	49 f0       	breq	.+18     	; 0x5d8 <__stack+0x179>
		//Kondensator wieder entladen
		tmpint = 0;
		extcnt = 0;
		R_DDR = (1<<(2*HighPin));			//High-Pin über R_L auf Masse
		R_PORT = 0;
		while(ReadADC(HighPin) > (ReadADC(LowPin) + 10)) {
     5c6:	81 2f       	mov	r24, r17
     5c8:	07 de       	rcall	.-1010   	; 0x1d8 <ReadADC>
     5ca:	7c 01       	movw	r14, r24
     5cc:	8b 2d       	mov	r24, r11
     5ce:	04 de       	rcall	.-1016   	; 0x1d8 <ReadADC>
     5d0:	0a 96       	adiw	r24, 0x0a	; 10
     5d2:	8e 15       	cp	r24, r14
     5d4:	9f 05       	cpc	r25, r15
     5d6:	68 f3       	brcs	.-38     	; 0x5b2 <__stack+0x153>
			if(tmpint==0) {
				extcnt++;
				if(extcnt == 30) break; //Timeout für Entladung
			}
		}
		ADC_DDR = 7 | (1<<TxD);	//komplett entladen
     5d8:	8f e0       	ldi	r24, 0x0F	; 15
     5da:	84 bb       	out	0x14, r24	; 20
		ADC_PORT = 7 | TXD_VAL;
     5dc:	87 e0       	ldi	r24, 0x07	; 7
     5de:	85 bb       	out	0x15, r24	; 21
     5e0:	83 ec       	ldi	r24, 0xC3	; 195
     5e2:	99 e0       	ldi	r25, 0x09	; 9
     5e4:	01 97       	sbiw	r24, 0x01	; 1
     5e6:	f1 f7       	brne	.-4      	; 0x5e4 <__stack+0x185>
     5e8:	00 c0       	rjmp	.+0      	; 0x5ea <__stack+0x18b>
     5ea:	00 00       	nop
		_delay_ms(10);
		//Fertig
	}
	end:
	ADC_DDR =  (1<<TxD);				
     5ec:	88 e0       	ldi	r24, 0x08	; 8
     5ee:	84 bb       	out	0x14, r24	; 20
	ADC_PORT = TXD_VAL;
     5f0:	15 ba       	out	0x15, r1	; 21
	R_DDR = 0;
     5f2:	17 ba       	out	0x17, r1	; 23
	R_PORT = 0; 
     5f4:	18 ba       	out	0x18, r1	; 24
}
     5f6:	0f 90       	pop	r0
     5f8:	cf 91       	pop	r28
     5fa:	df 91       	pop	r29
     5fc:	1f 91       	pop	r17
     5fe:	0f 91       	pop	r16
     600:	ff 90       	pop	r15
     602:	ef 90       	pop	r14
     604:	df 90       	pop	r13
     606:	cf 90       	pop	r12
     608:	bf 90       	pop	r11
     60a:	af 90       	pop	r10
     60c:	9f 90       	pop	r9
     60e:	8f 90       	pop	r8
     610:	08 95       	ret
				}
			}
			tmpx = 1;
		}
		if(tmpx) {
			gcval = eeprom_read_word(&H_CAPACITY_FACTOR);
     612:	88 e0       	ldi	r24, 0x08	; 8
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	21 db       	rcall	.-2494   	; 0xfffffc5a <__eeprom_end+0xff7efafa>
			if((extcnt == 0) && (tmpint < 5)) goto end;	//Kapazität zu gering
     618:	cc 20       	and	r12, r12
     61a:	09 f4       	brne	.+2      	; 0x61e <__stack+0x1bf>
     61c:	84 cf       	rjmp	.-248    	; 0x526 <__stack+0xc7>
     61e:	88 cf       	rjmp	.-240    	; 0x530 <__stack+0xd1>

00000620 <CheckPins>:
		}
	}
	return 0;
}

void CheckPins(uint8_t HighPin, uint8_t LowPin, uint8_t TristatePin) {
     620:	2f 92       	push	r2
     622:	3f 92       	push	r3
     624:	4f 92       	push	r4
     626:	5f 92       	push	r5
     628:	6f 92       	push	r6
     62a:	7f 92       	push	r7
     62c:	8f 92       	push	r8
     62e:	9f 92       	push	r9
     630:	af 92       	push	r10
     632:	bf 92       	push	r11
     634:	cf 92       	push	r12
     636:	df 92       	push	r13
     638:	ef 92       	push	r14
     63a:	ff 92       	push	r15
     63c:	0f 93       	push	r16
     63e:	1f 93       	push	r17
     640:	df 93       	push	r29
     642:	cf 93       	push	r28
     644:	00 d0       	rcall	.+0      	; 0x646 <CheckPins+0x26>
     646:	00 d0       	rcall	.+0      	; 0x648 <CheckPins+0x28>
     648:	cd b7       	in	r28, 0x3d	; 61
     64a:	de b7       	in	r29, 0x3e	; 62
     64c:	18 2f       	mov	r17, r24
     64e:	06 2f       	mov	r16, r22
     650:	a4 2e       	mov	r10, r20
	/*
		HighPin wird fest auf Vcc gelegt
		LowPin wird über R_L auf GND gelegt
		TristatePin wird hochohmig geschaltet, dafür ist keine Aktion nötig
	*/
	wdt_reset();
     652:	a8 95       	wdr
	//Pins setzen
	tmpval = (LowPin * 2);			//nötig wegen der Anordnung der Widerstände
     654:	26 2f       	mov	r18, r22
     656:	22 0f       	add	r18, r18
	R_DDR = (1<<tmpval);			//Low-Pin auf Ausgang und über R_L auf Masse
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	ac 01       	movw	r20, r24
     65e:	02 c0       	rjmp	.+4      	; 0x664 <CheckPins+0x44>
     660:	44 0f       	add	r20, r20
     662:	55 1f       	adc	r21, r21
     664:	2a 95       	dec	r18
     666:	e2 f7       	brpl	.-8      	; 0x660 <CheckPins+0x40>
     668:	84 2e       	mov	r8, r20
     66a:	47 bb       	out	0x17, r20	; 23
	R_PORT = 0;
     66c:	18 ba       	out	0x18, r1	; 24
	ADC_DDR = (1<<HighPin) | (1<<TxD);			//High-Pin auf Ausgang
     66e:	61 2f       	mov	r22, r17
     670:	70 e0       	ldi	r23, 0x00	; 0
     672:	7a 83       	std	Y+2, r23	; 0x02
     674:	69 83       	std	Y+1, r22	; 0x01
     676:	01 2e       	mov	r0, r17
     678:	02 c0       	rjmp	.+4      	; 0x67e <CheckPins+0x5e>
     67a:	88 0f       	add	r24, r24
     67c:	99 1f       	adc	r25, r25
     67e:	0a 94       	dec	r0
     680:	e2 f7       	brpl	.-8      	; 0x67a <CheckPins+0x5a>
     682:	28 e0       	ldi	r18, 0x08	; 8
     684:	32 2e       	mov	r3, r18
     686:	38 2a       	or	r3, r24
     688:	34 ba       	out	0x14, r3	; 20
	ADC_PORT = (1<<HighPin) | TXD_VAL;		//High-Pin fest auf Vcc
     68a:	28 2e       	mov	r2, r24
     68c:	85 bb       	out	0x15, r24	; 21
     68e:	81 ee       	ldi	r24, 0xE1	; 225
     690:	94 e0       	ldi	r25, 0x04	; 4
     692:	01 97       	sbiw	r24, 0x01	; 1
     694:	f1 f7       	brne	.-4      	; 0x692 <CheckPins+0x72>
     696:	00 c0       	rjmp	.+0      	; 0x698 <CheckPins+0x78>
     698:	00 00       	nop
	_delay_ms(5);
	//Bei manchen MOSFETs muss das Gate (TristatePin) zuerst entladen werden
	//N-Kanal:
	DischargePin(TristatePin,0);
     69a:	8a 2d       	mov	r24, r10
     69c:	60 e0       	ldi	r22, 0x00	; 0
     69e:	af dd       	rcall	.-1186   	; 0x1fe <DischargePin>
	//Spannung am Low-Pin ermitteln
	adcv[0] = ReadADC(LowPin);
     6a0:	80 2f       	mov	r24, r16
     6a2:	9a dd       	rcall	.-1228   	; 0x1d8 <ReadADC>
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	8b 83       	std	Y+3, r24	; 0x03
	if(adcv[0] < 200) goto next;	//Sperrt das Bauteil jetzt?
     6a8:	88 3c       	cpi	r24, 0xC8	; 200
     6aa:	91 05       	cpc	r25, r1
     6ac:	38 f0       	brcs	.+14     	; 0x6bc <CheckPins+0x9c>
	//sonst: Entladen für P-Kanal (Gate auf Plus)
	DischargePin(TristatePin,1);
     6ae:	8a 2d       	mov	r24, r10
     6b0:	61 e0       	ldi	r22, 0x01	; 1
     6b2:	a5 dd       	rcall	.-1206   	; 0x1fe <DischargePin>
	//Spannung am Low-Pin ermitteln
	adcv[0] = ReadADC(LowPin);
     6b4:	80 2f       	mov	r24, r16
     6b6:	90 dd       	rcall	.-1248   	; 0x1d8 <ReadADC>
     6b8:	9c 83       	std	Y+4, r25	; 0x04
     6ba:	8b 83       	std	Y+3, r24	; 0x03

	next:

	if(adcv[0] > 19) {//Bauteil leitet ohne Steuerstrom etwas
     6bc:	eb 81       	ldd	r30, Y+3	; 0x03
     6be:	fc 81       	ldd	r31, Y+4	; 0x04
     6c0:	e4 31       	cpi	r30, 0x14	; 20
     6c2:	f1 05       	cpc	r31, r1
     6c4:	08 f4       	brcc	.+2      	; 0x6c8 <CheckPins+0xa8>
     6c6:	ac c0       	rjmp	.+344    	; 0x820 <CheckPins+0x200>
		//Test auf N-JFET oder selbstleitenden N-MOSFET
		R_DDR |= (2<<(TristatePin*2));	//Tristate-Pin (vermutetes Gate) über R_H auf Masse
     6c8:	27 b3       	in	r18, 0x17	; 23
     6ca:	3a 2d       	mov	r19, r10
     6cc:	33 0f       	add	r19, r19
     6ce:	82 e0       	ldi	r24, 0x02	; 2
     6d0:	90 e0       	ldi	r25, 0x00	; 0
     6d2:	02 c0       	rjmp	.+4      	; 0x6d8 <CheckPins+0xb8>
     6d4:	88 0f       	add	r24, r24
     6d6:	99 1f       	adc	r25, r25
     6d8:	3a 95       	dec	r19
     6da:	e2 f7       	brpl	.-8      	; 0x6d4 <CheckPins+0xb4>
     6dc:	c8 2e       	mov	r12, r24
     6de:	28 2b       	or	r18, r24
     6e0:	27 bb       	out	0x17, r18	; 23
     6e2:	87 e8       	ldi	r24, 0x87	; 135
     6e4:	93 e1       	ldi	r25, 0x13	; 19
     6e6:	01 97       	sbiw	r24, 0x01	; 1
     6e8:	f1 f7       	brne	.-4      	; 0x6e6 <CheckPins+0xc6>
     6ea:	00 c0       	rjmp	.+0      	; 0x6ec <CheckPins+0xcc>
     6ec:	00 00       	nop
		_delay_ms(20);
		adcv[1] = ReadADC(LowPin);		//Spannung am vermuteten Source messen
     6ee:	80 2f       	mov	r24, r16
     6f0:	73 dd       	rcall	.-1306   	; 0x1d8 <ReadADC>
     6f2:	7c 01       	movw	r14, r24
		R_PORT |= (2<<(TristatePin*2));	//Tristate-Pin (vermutetes Gate) über R_H auf Plus
     6f4:	88 b3       	in	r24, 0x18	; 24
     6f6:	8c 29       	or	r24, r12
     6f8:	88 bb       	out	0x18, r24	; 24
     6fa:	e7 e8       	ldi	r30, 0x87	; 135
     6fc:	f3 e1       	ldi	r31, 0x13	; 19
     6fe:	31 97       	sbiw	r30, 0x01	; 1
     700:	f1 f7       	brne	.-4      	; 0x6fe <CheckPins+0xde>
     702:	00 c0       	rjmp	.+0      	; 0x704 <CheckPins+0xe4>
     704:	00 00       	nop
		_delay_ms(20);
		adcv[2] = ReadADC(LowPin);		//Spannung am vermuteten Source erneut messen
     706:	80 2f       	mov	r24, r16
     708:	67 dd       	rcall	.-1330   	; 0x1d8 <ReadADC>
		//Wenn es sich um einen selbstleitenden MOSFET oder JFET handelt, müsste adcv[1] > adcv[0] sein
		if(adcv[2]>(adcv[1]+100)) {
     70a:	97 01       	movw	r18, r14
     70c:	2c 59       	subi	r18, 0x9C	; 156
     70e:	3f 4f       	sbci	r19, 0xFF	; 255
     710:	28 17       	cp	r18, r24
     712:	39 07       	cpc	r19, r25
     714:	a8 f5       	brcc	.+106    	; 0x780 <CheckPins+0x160>
			//Spannung am Gate messen, zur Unterscheidung zwischen MOSFET und JFET
			ADC_PORT = TXD_VAL;
     716:	15 ba       	out	0x15, r1	; 21
			ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin fest auf Masse
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	90 e0       	ldi	r25, 0x00	; 0
     71c:	9c 01       	movw	r18, r24
     71e:	00 2e       	mov	r0, r16
     720:	02 c0       	rjmp	.+4      	; 0x726 <CheckPins+0x106>
     722:	22 0f       	add	r18, r18
     724:	33 1f       	adc	r19, r19
     726:	0a 94       	dec	r0
     728:	e2 f7       	brpl	.-8      	; 0x722 <CheckPins+0x102>
     72a:	28 60       	ori	r18, 0x08	; 8
     72c:	24 bb       	out	0x14, r18	; 20
			tmpval = (HighPin * 2);		//nötig wegen der Anordnung der Widerstände
			R_DDR |= (1<<tmpval);			//High-Pin auf Ausgang
     72e:	27 b3       	in	r18, 0x17	; 23
		//Wenn es sich um einen selbstleitenden MOSFET oder JFET handelt, müsste adcv[1] > adcv[0] sein
		if(adcv[2]>(adcv[1]+100)) {
			//Spannung am Gate messen, zur Unterscheidung zwischen MOSFET und JFET
			ADC_PORT = TXD_VAL;
			ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin fest auf Masse
			tmpval = (HighPin * 2);		//nötig wegen der Anordnung der Widerstände
     730:	31 2f       	mov	r19, r17
     732:	33 0f       	add	r19, r19
			R_DDR |= (1<<tmpval);			//High-Pin auf Ausgang
     734:	02 c0       	rjmp	.+4      	; 0x73a <CheckPins+0x11a>
     736:	88 0f       	add	r24, r24
     738:	99 1f       	adc	r25, r25
     73a:	3a 95       	dec	r19
     73c:	e2 f7       	brpl	.-8      	; 0x736 <CheckPins+0x116>
     73e:	28 2b       	or	r18, r24
     740:	27 bb       	out	0x17, r18	; 23
			R_PORT |= (1<<tmpval);			//High-Pin über R_L auf Vcc
     742:	98 b3       	in	r25, 0x18	; 24
     744:	98 2b       	or	r25, r24
     746:	98 bb       	out	0x18, r25	; 24
     748:	87 e8       	ldi	r24, 0x87	; 135
     74a:	93 e1       	ldi	r25, 0x13	; 19
     74c:	01 97       	sbiw	r24, 0x01	; 1
     74e:	f1 f7       	brne	.-4      	; 0x74c <CheckPins+0x12c>
     750:	00 c0       	rjmp	.+0      	; 0x752 <CheckPins+0x132>
     752:	00 00       	nop
			_delay_ms(20);
			adcv[2] = ReadADC(TristatePin);		//Spannung am vermuteten Gate messen
     754:	8a 2d       	mov	r24, r10
     756:	40 dd       	rcall	.-1408   	; 0x1d8 <ReadADC>
			if(adcv[2]>800) {	//MOSFET
     758:	e3 e0       	ldi	r30, 0x03	; 3
     75a:	81 32       	cpi	r24, 0x21	; 33
     75c:	9e 07       	cpc	r25, r30
     75e:	20 f0       	brcs	.+8      	; 0x768 <CheckPins+0x148>
				PartFound = PART_FET;			//N-Kanal-MOSFET
     760:	83 e0       	ldi	r24, 0x03	; 3
     762:	80 93 68 00 	sts	0x0068, r24
     766:	04 c0       	rjmp	.+8      	; 0x770 <CheckPins+0x150>
				PartMode = PART_MODE_N_D_MOS;	//Verarmungs-MOSFET
			} else {	//JFET (pn-Übergang zwischen G und S leitet)
				PartFound = PART_FET;			//N-Kanal-JFET
     768:	83 e0       	ldi	r24, 0x03	; 3
     76a:	80 93 68 00 	sts	0x0068, r24
				PartMode = PART_MODE_N_JFET;
     76e:	85 e0       	ldi	r24, 0x05	; 5
     770:	80 93 67 00 	sts	0x0067, r24
			}
			b = TristatePin;
     774:	a0 92 64 00 	sts	0x0064, r10
			c = HighPin;
     778:	10 93 83 00 	sts	0x0083, r17
			e = LowPin;
     77c:	00 93 a2 00 	sts	0x00A2, r16
		}
		ADC_PORT = TXD_VAL;
     780:	15 ba       	out	0x15, r1	; 21

		//Test auf P-JFET oder selbstleitenden P-MOSFET
		ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin (vermuteter Drain) fest auf Masse, Tristate-Pin (vermutetes Gate) ist noch über R_H auf Plus
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	9c 01       	movw	r18, r24
     788:	00 2e       	mov	r0, r16
     78a:	02 c0       	rjmp	.+4      	; 0x790 <CheckPins+0x170>
     78c:	22 0f       	add	r18, r18
     78e:	33 1f       	adc	r19, r19
     790:	0a 94       	dec	r0
     792:	e2 f7       	brpl	.-8      	; 0x78c <CheckPins+0x16c>
     794:	28 60       	ori	r18, 0x08	; 8
     796:	24 bb       	out	0x14, r18	; 20
		tmpval = (HighPin * 2);			//nötig wegen der Anordnung der Widerstände
		R_DDR |= (1<<tmpval);			//High-Pin auf Ausgang
     798:	27 b3       	in	r18, 0x17	; 23
		}
		ADC_PORT = TXD_VAL;

		//Test auf P-JFET oder selbstleitenden P-MOSFET
		ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin (vermuteter Drain) fest auf Masse, Tristate-Pin (vermutetes Gate) ist noch über R_H auf Plus
		tmpval = (HighPin * 2);			//nötig wegen der Anordnung der Widerstände
     79a:	e1 2e       	mov	r14, r17
     79c:	ee 0c       	add	r14, r14
		R_DDR |= (1<<tmpval);			//High-Pin auf Ausgang
     79e:	ac 01       	movw	r20, r24
     7a0:	02 c0       	rjmp	.+4      	; 0x7a6 <CheckPins+0x186>
     7a2:	44 0f       	add	r20, r20
     7a4:	55 1f       	adc	r21, r21
     7a6:	ea 94       	dec	r14
     7a8:	e2 f7       	brpl	.-8      	; 0x7a2 <CheckPins+0x182>
     7aa:	7a 01       	movw	r14, r20
     7ac:	24 2b       	or	r18, r20
     7ae:	27 bb       	out	0x17, r18	; 23
		R_PORT |= (1<<tmpval);			//High-Pin über R_L auf Vcc
     7b0:	88 b3       	in	r24, 0x18	; 24
     7b2:	84 2b       	or	r24, r20
     7b4:	88 bb       	out	0x18, r24	; 24
     7b6:	87 e8       	ldi	r24, 0x87	; 135
     7b8:	93 e1       	ldi	r25, 0x13	; 19
     7ba:	01 97       	sbiw	r24, 0x01	; 1
     7bc:	f1 f7       	brne	.-4      	; 0x7ba <CheckPins+0x19a>
     7be:	00 c0       	rjmp	.+0      	; 0x7c0 <CheckPins+0x1a0>
     7c0:	00 00       	nop
		_delay_ms(20);
		adcv[1] = ReadADC(HighPin);		//Spannung am vermuteten Source messen
     7c2:	81 2f       	mov	r24, r17
     7c4:	09 dd       	rcall	.-1518   	; 0x1d8 <ReadADC>
     7c6:	6c 01       	movw	r12, r24
		R_PORT = (1<<tmpval);			//Tristate-Pin (vermutetes Gate) über R_H auf Masse
     7c8:	e8 ba       	out	0x18, r14	; 24
     7ca:	e7 e8       	ldi	r30, 0x87	; 135
     7cc:	f3 e1       	ldi	r31, 0x13	; 19
     7ce:	31 97       	sbiw	r30, 0x01	; 1
     7d0:	f1 f7       	brne	.-4      	; 0x7ce <CheckPins+0x1ae>
     7d2:	00 c0       	rjmp	.+0      	; 0x7d4 <CheckPins+0x1b4>
     7d4:	00 00       	nop
		_delay_ms(20);
		adcv[2] = ReadADC(HighPin);		//Spannung am vermuteten Source erneut messen
     7d6:	81 2f       	mov	r24, r17
     7d8:	ff dc       	rcall	.-1538   	; 0x1d8 <ReadADC>
		//Wenn es sich um einen selbstleitenden P-MOSFET oder P-JFET handelt, müsste adcv[0] > adcv[1] sein
		if(adcv[1]>(adcv[2]+100)) {
     7da:	8c 59       	subi	r24, 0x9C	; 156
     7dc:	9f 4f       	sbci	r25, 0xFF	; 255
     7de:	8c 15       	cp	r24, r12
     7e0:	9d 05       	cpc	r25, r13
     7e2:	f0 f4       	brcc	.+60     	; 0x820 <CheckPins+0x200>
			//Spannung am Gate messen, zur Unterscheidung zwischen MOSFET und JFET
			ADC_PORT = (1<<HighPin) | TXD_VAL;	//High-Pin fest auf Plus
     7e4:	25 ba       	out	0x15, r2	; 21
			ADC_DDR = (1<<HighPin) | (1<<TxD);		//High-Pin auf Ausgang
     7e6:	34 ba       	out	0x14, r3	; 20
     7e8:	87 e8       	ldi	r24, 0x87	; 135
     7ea:	93 e1       	ldi	r25, 0x13	; 19
     7ec:	01 97       	sbiw	r24, 0x01	; 1
     7ee:	f1 f7       	brne	.-4      	; 0x7ec <CheckPins+0x1cc>
     7f0:	00 c0       	rjmp	.+0      	; 0x7f2 <CheckPins+0x1d2>
     7f2:	00 00       	nop
			_delay_ms(20);
			adcv[2] = ReadADC(TristatePin);		//Spannung am vermuteten Gate messen
     7f4:	8a 2d       	mov	r24, r10
     7f6:	f0 dc       	rcall	.-1568   	; 0x1d8 <ReadADC>
			if(adcv[2]<200) {	//MOSFET
     7f8:	88 3c       	cpi	r24, 0xC8	; 200
     7fa:	91 05       	cpc	r25, r1
     7fc:	28 f4       	brcc	.+10     	; 0x808 <CheckPins+0x1e8>
				PartFound = PART_FET;			//P-Kanal-MOSFET
     7fe:	83 e0       	ldi	r24, 0x03	; 3
     800:	80 93 68 00 	sts	0x0068, r24
				PartMode = PART_MODE_P_D_MOS;	//Verarmungs-MOSFET
     804:	84 e0       	ldi	r24, 0x04	; 4
     806:	04 c0       	rjmp	.+8      	; 0x810 <CheckPins+0x1f0>
			} else {	//JFET (pn-Übergang zwischen G und S leitet)
				PartFound = PART_FET;			//P-Kanal-JFET
     808:	83 e0       	ldi	r24, 0x03	; 3
     80a:	80 93 68 00 	sts	0x0068, r24
				PartMode = PART_MODE_P_JFET;
     80e:	86 e0       	ldi	r24, 0x06	; 6
     810:	80 93 67 00 	sts	0x0067, r24
			}
			b = TristatePin;
     814:	a0 92 64 00 	sts	0x0064, r10
			c = LowPin;
     818:	00 93 83 00 	sts	0x0083, r16
			e = HighPin;
     81c:	10 93 a2 00 	sts	0x00A2, r17
		}
	}
	//Pins erneut setzen
	tmpval = (LowPin * 2);			//nötig wegen der Anordnung der Widerstände
	R_DDR = (1<<tmpval);			//Low-Pin auf Ausgang und über R_L auf Masse
     820:	87 ba       	out	0x17, r8	; 23
	R_PORT = 0;
     822:	18 ba       	out	0x18, r1	; 24
	ADC_DDR = (1<<HighPin) | (1<<TxD);			//High-Pin auf Ausgang
     824:	34 ba       	out	0x14, r3	; 20
	ADC_PORT = (1<<HighPin) | TXD_VAL;		//High-Pin fest auf Vcc
     826:	25 ba       	out	0x15, r2	; 21
     828:	e1 ee       	ldi	r30, 0xE1	; 225
     82a:	f4 e0       	ldi	r31, 0x04	; 4
     82c:	31 97       	sbiw	r30, 0x01	; 1
     82e:	f1 f7       	brne	.-4      	; 0x82c <CheckPins+0x20c>
     830:	00 c0       	rjmp	.+0      	; 0x832 <CheckPins+0x212>
     832:	00 00       	nop
	_delay_ms(5);
	
	if(adcv[0] < 200) {	//Wenn das Bauteil keinen Durchgang zwischen HighPin und LowPin hat
     834:	2b 81       	ldd	r18, Y+3	; 0x03
     836:	3c 81       	ldd	r19, Y+4	; 0x04
     838:	28 3c       	cpi	r18, 0xC8	; 200
     83a:	31 05       	cpc	r19, r1
     83c:	08 f0       	brcs	.+2      	; 0x840 <CheckPins+0x220>
     83e:	ed c1       	rjmp	.+986    	; 0xc1a <CheckPins+0x5fa>
		//Test auf pnp
		tmpval2 = (TristatePin * 2);		//nötig wegen der Anordnung der Widerstände
     840:	ca 2c       	mov	r12, r10
     842:	cc 0c       	add	r12, r12
		R_DDR |= (1<<tmpval2);			//Tristate-Pin über R_L auf Masse, zum Test auf pnp
     844:	87 b3       	in	r24, 0x17	; 23
     846:	91 e0       	ldi	r25, 0x01	; 1
     848:	e9 2e       	mov	r14, r25
     84a:	f1 2c       	mov	r15, r1
     84c:	37 01       	movw	r6, r14
     84e:	0c 2c       	mov	r0, r12
     850:	02 c0       	rjmp	.+4      	; 0x856 <CheckPins+0x236>
     852:	66 0c       	add	r6, r6
     854:	77 1c       	adc	r7, r7
     856:	0a 94       	dec	r0
     858:	e2 f7       	brpl	.-8      	; 0x852 <CheckPins+0x232>
     85a:	86 29       	or	r24, r6
     85c:	87 bb       	out	0x17, r24	; 23
     85e:	83 ef       	ldi	r24, 0xF3	; 243
     860:	91 e0       	ldi	r25, 0x01	; 1
     862:	01 97       	sbiw	r24, 0x01	; 1
     864:	f1 f7       	brne	.-4      	; 0x862 <CheckPins+0x242>
     866:	00 c0       	rjmp	.+0      	; 0x868 <CheckPins+0x248>
     868:	00 00       	nop
		_delay_ms(2);
		adcv[1] = ReadADC(LowPin);		//Spannung messen
     86a:	80 2f       	mov	r24, r16
     86c:	b5 dc       	rcall	.-1686   	; 0x1d8 <ReadADC>
		if(adcv[1] > 700) {
     86e:	e2 e0       	ldi	r30, 0x02	; 2
     870:	8d 3b       	cpi	r24, 0xBD	; 189
     872:	9e 07       	cpc	r25, r30
     874:	08 f4       	brcc	.+2      	; 0x878 <CheckPins+0x258>
     876:	90 c0       	rjmp	.+288    	; 0x998 <CheckPins+0x378>
			//Bauteil leitet => pnp-Transistor o.ä.
			//Verstärkungsfaktor in beide Richtungen messen
			R_DDR = (1<<tmpval);		//Tristate-Pin (Basis) hochohmig
     878:	87 ba       	out	0x17, r8	; 23
			tmpval2++;
			R_DDR |= (1<<tmpval2);		//Tristate-Pin (Basis) über R_H auf Masse
     87a:	87 b3       	in	r24, 0x17	; 23
		adcv[1] = ReadADC(LowPin);		//Spannung messen
		if(adcv[1] > 700) {
			//Bauteil leitet => pnp-Transistor o.ä.
			//Verstärkungsfaktor in beide Richtungen messen
			R_DDR = (1<<tmpval);		//Tristate-Pin (Basis) hochohmig
			tmpval2++;
     87c:	9c 2d       	mov	r25, r12
     87e:	9f 5f       	subi	r25, 0xFF	; 255
			R_DDR |= (1<<tmpval2);		//Tristate-Pin (Basis) über R_H auf Masse
     880:	02 c0       	rjmp	.+4      	; 0x886 <CheckPins+0x266>
     882:	ee 0c       	add	r14, r14
     884:	ff 1c       	adc	r15, r15
     886:	9a 95       	dec	r25
     888:	e2 f7       	brpl	.-8      	; 0x882 <CheckPins+0x262>
     88a:	8e 29       	or	r24, r14
     88c:	87 bb       	out	0x17, r24	; 23
     88e:	83 ec       	ldi	r24, 0xC3	; 195
     890:	99 e0       	ldi	r25, 0x09	; 9
     892:	01 97       	sbiw	r24, 0x01	; 1
     894:	f1 f7       	brne	.-4      	; 0x892 <CheckPins+0x272>
     896:	00 c0       	rjmp	.+0      	; 0x898 <CheckPins+0x278>
     898:	00 00       	nop

			_delay_ms(10);
			adcv[1] = ReadADC(LowPin);		//Spannung am Low-Pin (vermuteter Kollektor) messen
     89a:	80 2f       	mov	r24, r16
     89c:	9d dc       	rcall	.-1734   	; 0x1d8 <ReadADC>
     89e:	7c 01       	movw	r14, r24
			adcv[2] = ReadADC(TristatePin);	//Basisspannung messen
     8a0:	8a 2d       	mov	r24, r10
     8a2:	9a dc       	rcall	.-1740   	; 0x1d8 <ReadADC>
			//Prüfen, ob Test schon mal gelaufen
			if((PartFound == PART_TRANSISTOR) || (PartFound == PART_FET)) PartReady = 1;
     8a4:	40 91 68 00 	lds	r20, 0x0068
     8a8:	24 2f       	mov	r18, r20
     8aa:	22 50       	subi	r18, 0x02	; 2
     8ac:	22 30       	cpi	r18, 0x02	; 2
     8ae:	18 f4       	brcc	.+6      	; 0x8b6 <CheckPins+0x296>
     8b0:	21 e0       	ldi	r18, 0x01	; 1
     8b2:	20 93 65 00 	sts	0x0065, r18
			hfe[PartReady] = adcv[1];
     8b6:	20 91 65 00 	lds	r18, 0x0065
     8ba:	30 e0       	ldi	r19, 0x00	; 0
     8bc:	22 0f       	add	r18, r18
     8be:	33 1f       	adc	r19, r19
     8c0:	f9 01       	movw	r30, r18
     8c2:	e4 56       	subi	r30, 0x64	; 100
     8c4:	ff 4f       	sbci	r31, 0xFF	; 255
     8c6:	f1 82       	std	Z+1, r15	; 0x01
     8c8:	e0 82       	st	Z, r14
			uBE[PartReady] = adcv[2];
     8ca:	24 57       	subi	r18, 0x74	; 116
     8cc:	3f 4f       	sbci	r19, 0xFF	; 255
     8ce:	f9 01       	movw	r30, r18
     8d0:	91 83       	std	Z+1, r25	; 0x01
     8d2:	80 83       	st	Z, r24

			if(PartFound != PART_THYRISTOR) {
     8d4:	45 30       	cpi	r20, 0x05	; 5
     8d6:	09 f4       	brne	.+2      	; 0x8da <CheckPins+0x2ba>
     8d8:	5f c0       	rjmp	.+190    	; 0x998 <CheckPins+0x378>
				if(adcv[2] > 200) {
     8da:	89 3c       	cpi	r24, 0xC9	; 201
     8dc:	91 05       	cpc	r25, r1
     8de:	30 f0       	brcs	.+12     	; 0x8ec <CheckPins+0x2cc>
					PartFound = PART_TRANSISTOR;	//PNP-Transistor gefunden (Basis wird "nach oben" gezogen)
     8e0:	82 e0       	ldi	r24, 0x02	; 2
     8e2:	80 93 68 00 	sts	0x0068, r24
					PartMode = PART_MODE_PNP;
     8e6:	80 93 67 00 	sts	0x0067, r24
     8ea:	50 c0       	rjmp	.+160    	; 0x98c <CheckPins+0x36c>
				} else {
					if(adcv[0] < 20) {	//Durchlassspannung im gesperrten Zustand gering genug? (sonst werden D-Mode-FETs fälschlicherweise als E-Mode erkannt)
     8ec:	2b 81       	ldd	r18, Y+3	; 0x03
     8ee:	3c 81       	ldd	r19, Y+4	; 0x04
     8f0:	24 31       	cpi	r18, 0x14	; 20
     8f2:	31 05       	cpc	r19, r1
     8f4:	08 f0       	brcs	.+2      	; 0x8f8 <CheckPins+0x2d8>
     8f6:	4a c0       	rjmp	.+148    	; 0x98c <CheckPins+0x36c>
					 	PartFound = PART_FET;			//P-Kanal-MOSFET gefunden (Basis/Gate wird NICHT "nach oben" gezogen)
     8f8:	83 e0       	ldi	r24, 0x03	; 3
     8fa:	80 93 68 00 	sts	0x0068, r24
						PartMode = PART_MODE_P_E_MOS;
     8fe:	82 e0       	ldi	r24, 0x02	; 2
     900:	80 93 67 00 	sts	0x0067, r24
						//Messung der Gate-Schwellspannung
						tmpval = (1<<LowPin);
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	00 2e       	mov	r0, r16
     90a:	02 c0       	rjmp	.+4      	; 0x910 <CheckPins+0x2f0>
     90c:	88 0f       	add	r24, r24
     90e:	99 1f       	adc	r25, r25
     910:	0a 94       	dec	r0
     912:	e2 f7       	brpl	.-8      	; 0x90c <CheckPins+0x2ec>
     914:	88 2e       	mov	r8, r24
						tmpval2 = R_DDR;
     916:	e7 b2       	in	r14, 0x17	; 23
						ADMUX = TristatePin | (1<<REFS0);
     918:	8a 2d       	mov	r24, r10
     91a:	80 64       	ori	r24, 0x40	; 64
     91c:	87 b9       	out	0x07, r24	; 7
						gthvoltage = 0;
     91e:	10 92 9a 00 	sts	0x009A, r1
     922:	10 92 99 00 	sts	0x0099, r1
						for(b=0;b<13;b++) {
     926:	10 92 64 00 	sts	0x0064, r1
     92a:	1f c0       	rjmp	.+62     	; 0x96a <CheckPins+0x34a>
							wdt_reset();
     92c:	a8 95       	wdr
							DischargePin(TristatePin,1);
     92e:	8a 2d       	mov	r24, r10
     930:	61 e0       	ldi	r22, 0x01	; 1
     932:	65 dc       	rcall	.-1846   	; 0x1fe <DischargePin>
							while (!(ADC_PIN&tmpval));  // Warten, bis der MOSFET schaltet und Drain auf high geht
     934:	83 b3       	in	r24, 0x13	; 19
     936:	88 21       	and	r24, r8
     938:	e9 f3       	breq	.-6      	; 0x934 <CheckPins+0x314>
							R_DDR = 0;
     93a:	17 ba       	out	0x17, r1	; 23
							ADCSRA |= (1<<ADSC);
     93c:	36 9a       	sbi	0x06, 6	; 6
							while (ADCSRA&(1<<ADSC));
     93e:	36 99       	sbic	0x06, 6	; 6
     940:	fe cf       	rjmp	.-4      	; 0x93e <CheckPins+0x31e>
							gthvoltage += (1023 - ADCW);
     942:	24 b1       	in	r18, 0x04	; 4
     944:	35 b1       	in	r19, 0x05	; 5
     946:	80 91 99 00 	lds	r24, 0x0099
     94a:	90 91 9a 00 	lds	r25, 0x009A
     94e:	81 50       	subi	r24, 0x01	; 1
     950:	9c 4f       	sbci	r25, 0xFC	; 252
     952:	82 1b       	sub	r24, r18
     954:	93 0b       	sbc	r25, r19
     956:	90 93 9a 00 	sts	0x009A, r25
     95a:	80 93 99 00 	sts	0x0099, r24
							R_DDR = tmpval2;
     95e:	e7 ba       	out	0x17, r14	; 23
						//Messung der Gate-Schwellspannung
						tmpval = (1<<LowPin);
						tmpval2 = R_DDR;
						ADMUX = TristatePin | (1<<REFS0);
						gthvoltage = 0;
						for(b=0;b<13;b++) {
     960:	80 91 64 00 	lds	r24, 0x0064
     964:	8f 5f       	subi	r24, 0xFF	; 255
     966:	80 93 64 00 	sts	0x0064, r24
     96a:	80 91 64 00 	lds	r24, 0x0064
     96e:	8d 30       	cpi	r24, 0x0D	; 13
     970:	e8 f2       	brcs	.-70     	; 0x92c <CheckPins+0x30c>
							ADCSRA |= (1<<ADSC);
							while (ADCSRA&(1<<ADSC));
							gthvoltage += (1023 - ADCW);
							R_DDR = tmpval2;
						}
						gthvoltage *= 3;	//Umrechnung in mV, zusammen mit der Division durch 8 (bei der LCD-Anzeige)
     972:	20 91 99 00 	lds	r18, 0x0099
     976:	30 91 9a 00 	lds	r19, 0x009A
     97a:	c9 01       	movw	r24, r18
     97c:	88 0f       	add	r24, r24
     97e:	99 1f       	adc	r25, r25
     980:	82 0f       	add	r24, r18
     982:	93 1f       	adc	r25, r19
     984:	90 93 9a 00 	sts	0x009A, r25
     988:	80 93 99 00 	sts	0x0099, r24
					}
				}
				b = TristatePin;
     98c:	a0 92 64 00 	sts	0x0064, r10
				c = LowPin;
     990:	00 93 83 00 	sts	0x0083, r16
				e = HighPin;
     994:	10 93 a2 00 	sts	0x00A2, r17
			}
		}

		//Tristate (vermutete Basis) auf Plus, zum Test auf npn
		ADC_PORT = TXD_VAL;					//Low-Pin fest auf Masse
     998:	15 ba       	out	0x15, r1	; 21
		tmpval = (TristatePin * 2);		//nötig wegen der Anordnung der Widerstände
		tmpval2 = (HighPin * 2);		//nötig wegen der Anordnung der Widerstände
     99a:	e1 2e       	mov	r14, r17
     99c:	ee 0c       	add	r14, r14
		R_DDR = (1<<tmpval) | (1<<tmpval2);			//High-Pin und Tristate-Pin auf Ausgang
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	ac 01       	movw	r20, r24
     9a4:	02 c0       	rjmp	.+4      	; 0x9aa <CheckPins+0x38a>
     9a6:	44 0f       	add	r20, r20
     9a8:	55 1f       	adc	r21, r21
     9aa:	ea 94       	dec	r14
     9ac:	e2 f7       	brpl	.-8      	; 0x9a6 <CheckPins+0x386>
     9ae:	7a 01       	movw	r14, r20
     9b0:	26 2d       	mov	r18, r6
     9b2:	24 2b       	or	r18, r20
     9b4:	27 bb       	out	0x17, r18	; 23
		R_PORT = (1<<tmpval) | (1<<tmpval2);		//High-Pin und Tristate-Pin über R_L auf Vcc
     9b6:	28 bb       	out	0x18, r18	; 24
		ADC_DDR = (1<<LowPin) | (1<<TxD);			//Low-Pin auf Ausgang
     9b8:	2c 01       	movw	r4, r24
     9ba:	00 2e       	mov	r0, r16
     9bc:	02 c0       	rjmp	.+4      	; 0x9c2 <CheckPins+0x3a2>
     9be:	44 0c       	add	r4, r4
     9c0:	55 1c       	adc	r5, r5
     9c2:	0a 94       	dec	r0
     9c4:	e2 f7       	brpl	.-8      	; 0x9be <CheckPins+0x39e>
     9c6:	84 2d       	mov	r24, r4
     9c8:	88 60       	ori	r24, 0x08	; 8
     9ca:	84 bb       	out	0x14, r24	; 20
     9cc:	83 ec       	ldi	r24, 0xC3	; 195
     9ce:	99 e0       	ldi	r25, 0x09	; 9
     9d0:	01 97       	sbiw	r24, 0x01	; 1
     9d2:	f1 f7       	brne	.-4      	; 0x9d0 <CheckPins+0x3b0>
     9d4:	00 c0       	rjmp	.+0      	; 0x9d6 <CheckPins+0x3b6>
     9d6:	00 00       	nop
		_delay_ms(10);
		adcv[1] = ReadADC(HighPin);		//Spannung am High-Pin messen
     9d8:	81 2f       	mov	r24, r17
     9da:	fe db       	rcall	.-2052   	; 0x1d8 <ReadADC>
		if(adcv[1] < 500) {
     9dc:	e1 e0       	ldi	r30, 0x01	; 1
     9de:	84 3f       	cpi	r24, 0xF4	; 244
     9e0:	9e 07       	cpc	r25, r30
     9e2:	08 f0       	brcs	.+2      	; 0x9e6 <CheckPins+0x3c6>
     9e4:	16 c1       	rjmp	.+556    	; 0xc12 <CheckPins+0x5f2>
			if(PartReady==1) goto testend;
     9e6:	80 91 65 00 	lds	r24, 0x0065
     9ea:	81 30       	cpi	r24, 0x01	; 1
     9ec:	09 f4       	brne	.+2      	; 0x9f0 <CheckPins+0x3d0>
     9ee:	05 c3       	rjmp	.+1546   	; 0xffa <CheckPins+0x9da>
			//Bauteil leitet => npn-Transistor o.ä.

			//Test auf Thyristor:
			//Gate entladen
			
			R_PORT = (1<<tmpval2);			//Tristate-Pin (Gate) über R_L auf Masse
     9f0:	e8 ba       	out	0x18, r14	; 24
     9f2:	83 ec       	ldi	r24, 0xC3	; 195
     9f4:	99 e0       	ldi	r25, 0x09	; 9
     9f6:	01 97       	sbiw	r24, 0x01	; 1
     9f8:	f1 f7       	brne	.-4      	; 0x9f6 <CheckPins+0x3d6>
     9fa:	00 c0       	rjmp	.+0      	; 0x9fc <CheckPins+0x3dc>
     9fc:	00 00       	nop
			_delay_ms(10);
			R_DDR = (1<<tmpval2);			//Tristate-Pin (Gate) hochohmig
     9fe:	e7 ba       	out	0x17, r14	; 23
     a00:	e1 ee       	ldi	r30, 0xE1	; 225
     a02:	f4 e0       	ldi	r31, 0x04	; 4
     a04:	31 97       	sbiw	r30, 0x01	; 1
     a06:	f1 f7       	brne	.-4      	; 0xa04 <CheckPins+0x3e4>
     a08:	00 c0       	rjmp	.+0      	; 0xa0a <CheckPins+0x3ea>
     a0a:	00 00       	nop
			//Test auf Thyristor
			_delay_ms(5);
			adcv[3] = ReadADC(HighPin);		//Spannung am High-Pin (vermutete Anode) erneut messen
     a0c:	81 2f       	mov	r24, r17
     a0e:	e4 db       	rcall	.-2104   	; 0x1d8 <ReadADC>
     a10:	4c 01       	movw	r8, r24
			
			R_PORT = 0;						//High-Pin (vermutete Anode) auf Masse
     a12:	18 ba       	out	0x18, r1	; 24
     a14:	81 ee       	ldi	r24, 0xE1	; 225
     a16:	94 e0       	ldi	r25, 0x04	; 4
     a18:	01 97       	sbiw	r24, 0x01	; 1
     a1a:	f1 f7       	brne	.-4      	; 0xa18 <CheckPins+0x3f8>
     a1c:	00 c0       	rjmp	.+0      	; 0xa1e <CheckPins+0x3fe>
     a1e:	00 00       	nop
			_delay_ms(5);
			R_PORT = (1<<tmpval2);			//High-Pin (vermutete Anode) wieder auf Plus
     a20:	e8 ba       	out	0x18, r14	; 24
     a22:	e1 ee       	ldi	r30, 0xE1	; 225
     a24:	f4 e0       	ldi	r31, 0x04	; 4
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	f1 f7       	brne	.-4      	; 0xa26 <CheckPins+0x406>
     a2a:	00 c0       	rjmp	.+0      	; 0xa2c <CheckPins+0x40c>
     a2c:	00 00       	nop
			_delay_ms(5);
			adcv[2] = ReadADC(HighPin);		//Spannung am High-Pin (vermutete Anode) erneut messen
     a2e:	81 2f       	mov	r24, r17
     a30:	d3 db       	rcall	.-2138   	; 0x1d8 <ReadADC>
			if((adcv[3] < 500) && (adcv[2] > 900)) {	//Nach Abschalten des Haltestroms muss der Thyristor sperren
     a32:	f4 ef       	ldi	r31, 0xF4	; 244
     a34:	8f 16       	cp	r8, r31
     a36:	f1 e0       	ldi	r31, 0x01	; 1
     a38:	9f 06       	cpc	r9, r31
     a3a:	08 f0       	brcs	.+2      	; 0xa3e <CheckPins+0x41e>
     a3c:	5b c0       	rjmp	.+182    	; 0xaf4 <CheckPins+0x4d4>
     a3e:	23 e0       	ldi	r18, 0x03	; 3
     a40:	85 38       	cpi	r24, 0x85	; 133
     a42:	92 07       	cpc	r25, r18
     a44:	08 f4       	brcc	.+2      	; 0xa48 <CheckPins+0x428>
     a46:	56 c0       	rjmp	.+172    	; 0xaf4 <CheckPins+0x4d4>
				//war vor Abschaltung des Triggerstroms geschaltet und ist immer noch geschaltet obwohl Gate aus => Thyristor
				PartFound = PART_THYRISTOR;
     a48:	85 e0       	ldi	r24, 0x05	; 5
     a4a:	80 93 68 00 	sts	0x0068, r24
				//Test auf Triac
				R_DDR = 0;
     a4e:	17 ba       	out	0x17, r1	; 23
				R_PORT = 0;
     a50:	18 ba       	out	0x18, r1	; 24
				ADC_PORT = (1<<LowPin) | TXD_VAL;	//Low-Pin fest auf Plus
     a52:	45 ba       	out	0x15, r4	; 21
     a54:	81 ee       	ldi	r24, 0xE1	; 225
     a56:	94 e0       	ldi	r25, 0x04	; 4
     a58:	01 97       	sbiw	r24, 0x01	; 1
     a5a:	f1 f7       	brne	.-4      	; 0xa58 <CheckPins+0x438>
     a5c:	00 c0       	rjmp	.+0      	; 0xa5e <CheckPins+0x43e>
     a5e:	00 00       	nop
				_delay_ms(5);
				R_DDR = (1<<tmpval2);	//HighPin über R_L auf Masse
     a60:	e7 ba       	out	0x17, r14	; 23
     a62:	e1 ee       	ldi	r30, 0xE1	; 225
     a64:	f4 e0       	ldi	r31, 0x04	; 4
     a66:	31 97       	sbiw	r30, 0x01	; 1
     a68:	f1 f7       	brne	.-4      	; 0xa66 <CheckPins+0x446>
     a6a:	00 c0       	rjmp	.+0      	; 0xa6c <CheckPins+0x44c>
     a6c:	00 00       	nop
				_delay_ms(5);
				if(ReadADC(HighPin) > 50) goto savenresult;	//Spannung am High-Pin (vermuteter A2) messen; falls zu hoch: Bauteil leitet jetzt => kein Triac
     a6e:	81 2f       	mov	r24, r17
     a70:	b3 db       	rcall	.-2202   	; 0x1d8 <ReadADC>
     a72:	83 33       	cpi	r24, 0x33	; 51
     a74:	91 05       	cpc	r25, r1
     a76:	08 f0       	brcs	.+2      	; 0xa7a <CheckPins+0x45a>
     a78:	c6 c0       	rjmp	.+396    	; 0xc06 <CheckPins+0x5e6>
				R_DDR |= (1<<tmpval);	//Gate auch über R_L auf Masse => Triac müsste zünden
     a7a:	87 b3       	in	r24, 0x17	; 23
     a7c:	86 29       	or	r24, r6
     a7e:	87 bb       	out	0x17, r24	; 23
     a80:	81 ee       	ldi	r24, 0xE1	; 225
     a82:	94 e0       	ldi	r25, 0x04	; 4
     a84:	01 97       	sbiw	r24, 0x01	; 1
     a86:	f1 f7       	brne	.-4      	; 0xa84 <CheckPins+0x464>
     a88:	00 c0       	rjmp	.+0      	; 0xa8a <CheckPins+0x46a>
     a8a:	00 00       	nop
				_delay_ms(5);
				if(ReadADC(TristatePin) < 200) goto savenresult; //Spannung am Tristate-Pin (vermutetes Gate) messen; Abbruch falls Spannung zu gering
     a8c:	8a 2d       	mov	r24, r10
     a8e:	a4 db       	rcall	.-2232   	; 0x1d8 <ReadADC>
     a90:	88 3c       	cpi	r24, 0xC8	; 200
     a92:	91 05       	cpc	r25, r1
     a94:	08 f4       	brcc	.+2      	; 0xa98 <CheckPins+0x478>
     a96:	b7 c0       	rjmp	.+366    	; 0xc06 <CheckPins+0x5e6>
				if(ReadADC(HighPin) < 150) goto savenresult; //Bauteil leitet jetzt nicht => kein Triac => Abbruch
     a98:	81 2f       	mov	r24, r17
     a9a:	9e db       	rcall	.-2244   	; 0x1d8 <ReadADC>
     a9c:	86 39       	cpi	r24, 0x96	; 150
     a9e:	91 05       	cpc	r25, r1
     aa0:	08 f4       	brcc	.+2      	; 0xaa4 <CheckPins+0x484>
     aa2:	b1 c0       	rjmp	.+354    	; 0xc06 <CheckPins+0x5e6>
				R_DDR = (1<<tmpval2);	//TristatePin (Gate) wieder hochohmig
     aa4:	e7 ba       	out	0x17, r14	; 23
     aa6:	e1 ee       	ldi	r30, 0xE1	; 225
     aa8:	f4 e0       	ldi	r31, 0x04	; 4
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	f1 f7       	brne	.-4      	; 0xaaa <CheckPins+0x48a>
     aae:	00 c0       	rjmp	.+0      	; 0xab0 <CheckPins+0x490>
     ab0:	00 00       	nop
				_delay_ms(5);
				if(ReadADC(HighPin) < 150) goto savenresult; //Bauteil leitet nach Abschalten des Gatestroms nicht mehr=> kein Triac => Abbruch
     ab2:	81 2f       	mov	r24, r17
     ab4:	91 db       	rcall	.-2270   	; 0x1d8 <ReadADC>
     ab6:	86 39       	cpi	r24, 0x96	; 150
     ab8:	91 05       	cpc	r25, r1
     aba:	08 f4       	brcc	.+2      	; 0xabe <CheckPins+0x49e>
     abc:	a4 c0       	rjmp	.+328    	; 0xc06 <CheckPins+0x5e6>
				R_PORT = (1<<tmpval2);	//HighPin über R_L auf Plus => Haltestrom aus
     abe:	e8 ba       	out	0x18, r14	; 24
     ac0:	81 ee       	ldi	r24, 0xE1	; 225
     ac2:	94 e0       	ldi	r25, 0x04	; 4
     ac4:	01 97       	sbiw	r24, 0x01	; 1
     ac6:	f1 f7       	brne	.-4      	; 0xac4 <CheckPins+0x4a4>
     ac8:	00 c0       	rjmp	.+0      	; 0xaca <CheckPins+0x4aa>
     aca:	00 00       	nop
				_delay_ms(5);
				R_PORT = 0;				//HighPin wieder über R_L auf Masse; Triac müsste jetzt sperren
     acc:	18 ba       	out	0x18, r1	; 24
     ace:	e1 ee       	ldi	r30, 0xE1	; 225
     ad0:	f4 e0       	ldi	r31, 0x04	; 4
     ad2:	31 97       	sbiw	r30, 0x01	; 1
     ad4:	f1 f7       	brne	.-4      	; 0xad2 <CheckPins+0x4b2>
     ad6:	00 c0       	rjmp	.+0      	; 0xad8 <CheckPins+0x4b8>
     ad8:	00 00       	nop
				_delay_ms(5);
				if(ReadADC(HighPin) > 50) goto savenresult;	//Spannung am High-Pin (vermuteter A2) messen; falls zu hoch: Bauteil leitet jetzt => kein Triac
     ada:	81 2f       	mov	r24, r17
     adc:	7d db       	rcall	.-2310   	; 0x1d8 <ReadADC>
     ade:	83 33       	cpi	r24, 0x33	; 51
     ae0:	91 05       	cpc	r25, r1
     ae2:	08 f0       	brcs	.+2      	; 0xae6 <CheckPins+0x4c6>
     ae4:	90 c0       	rjmp	.+288    	; 0xc06 <CheckPins+0x5e6>
				PartFound = PART_TRIAC;
     ae6:	84 e0       	ldi	r24, 0x04	; 4
     ae8:	80 93 68 00 	sts	0x0068, r24
				PartReady = 1;
     aec:	81 e0       	ldi	r24, 0x01	; 1
     aee:	80 93 65 00 	sts	0x0065, r24
				goto savenresult;
     af2:	89 c0       	rjmp	.+274    	; 0xc06 <CheckPins+0x5e6>
			}
			//Test auf Transistor oder MOSFET
			tmpval++;
			R_DDR |= (1<<tmpval);		//Tristate-Pin (Basis) auf Ausgang
     af4:	27 b3       	in	r18, 0x17	; 23
				PartFound = PART_TRIAC;
				PartReady = 1;
				goto savenresult;
			}
			//Test auf Transistor oder MOSFET
			tmpval++;
     af6:	c3 94       	inc	r12
			R_DDR |= (1<<tmpval);		//Tristate-Pin (Basis) auf Ausgang
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	90 e0       	ldi	r25, 0x00	; 0
     afc:	02 c0       	rjmp	.+4      	; 0xb02 <CheckPins+0x4e2>
     afe:	88 0f       	add	r24, r24
     b00:	99 1f       	adc	r25, r25
     b02:	ca 94       	dec	r12
     b04:	e2 f7       	brpl	.-8      	; 0xafe <CheckPins+0x4de>
     b06:	28 2b       	or	r18, r24
     b08:	27 bb       	out	0x17, r18	; 23
			R_PORT |= (1<<tmpval);		//Tristate-Pin (Basis) über R_H auf Plus
     b0a:	98 b3       	in	r25, 0x18	; 24
     b0c:	98 2b       	or	r25, r24
     b0e:	98 bb       	out	0x18, r25	; 24
     b10:	83 ed       	ldi	r24, 0xD3	; 211
     b12:	90 e3       	ldi	r25, 0x30	; 48
     b14:	01 97       	sbiw	r24, 0x01	; 1
     b16:	f1 f7       	brne	.-4      	; 0xb14 <CheckPins+0x4f4>
     b18:	00 c0       	rjmp	.+0      	; 0xb1a <CheckPins+0x4fa>
     b1a:	00 00       	nop
			_delay_ms(50);
			adcv[1] = ReadADC(HighPin);		//Spannung am High-Pin (vermuteter Kollektor) messen
     b1c:	81 2f       	mov	r24, r17
     b1e:	5c db       	rcall	.-2376   	; 0x1d8 <ReadADC>
     b20:	7c 01       	movw	r14, r24
			adcv[2] = ReadADC(TristatePin);	//Basisspannung messen
     b22:	8a 2d       	mov	r24, r10
     b24:	59 db       	rcall	.-2382   	; 0x1d8 <ReadADC>

			if((PartFound == PART_TRANSISTOR) || (PartFound == PART_FET)) PartReady = 1;	//prüfen, ob Test schon mal gelaufen
     b26:	20 91 68 00 	lds	r18, 0x0068
     b2a:	22 50       	subi	r18, 0x02	; 2
     b2c:	22 30       	cpi	r18, 0x02	; 2
     b2e:	18 f4       	brcc	.+6      	; 0xb36 <CheckPins+0x516>
     b30:	21 e0       	ldi	r18, 0x01	; 1
     b32:	20 93 65 00 	sts	0x0065, r18
			hfe[PartReady] = 1023 - adcv[1];
     b36:	20 91 65 00 	lds	r18, 0x0065
     b3a:	30 e0       	ldi	r19, 0x00	; 0
     b3c:	22 0f       	add	r18, r18
     b3e:	33 1f       	adc	r19, r19
     b40:	f9 01       	movw	r30, r18
     b42:	e4 56       	subi	r30, 0x64	; 100
     b44:	ff 4f       	sbci	r31, 0xFF	; 255
     b46:	4f ef       	ldi	r20, 0xFF	; 255
     b48:	53 e0       	ldi	r21, 0x03	; 3
     b4a:	ba 01       	movw	r22, r20
     b4c:	6e 19       	sub	r22, r14
     b4e:	7f 09       	sbc	r23, r15
     b50:	71 83       	std	Z+1, r23	; 0x01
     b52:	60 83       	st	Z, r22
			uBE[PartReady] = 1023 - adcv[2];
     b54:	24 57       	subi	r18, 0x74	; 116
     b56:	3f 4f       	sbci	r19, 0xFF	; 255
     b58:	48 1b       	sub	r20, r24
     b5a:	59 0b       	sbc	r21, r25
     b5c:	f9 01       	movw	r30, r18
     b5e:	51 83       	std	Z+1, r21	; 0x01
     b60:	40 83       	st	Z, r20
			if(adcv[2] < 500) {
     b62:	f1 e0       	ldi	r31, 0x01	; 1
     b64:	84 3f       	cpi	r24, 0xF4	; 244
     b66:	9f 07       	cpc	r25, r31
     b68:	38 f4       	brcc	.+14     	; 0xb78 <CheckPins+0x558>
				PartFound = PART_TRANSISTOR;	//NPN-Transistor gefunden (Basis wird "nach unten" gezogen)
     b6a:	82 e0       	ldi	r24, 0x02	; 2
     b6c:	80 93 68 00 	sts	0x0068, r24
				PartMode = PART_MODE_NPN;
     b70:	81 e0       	ldi	r24, 0x01	; 1
     b72:	80 93 67 00 	sts	0x0067, r24
     b76:	47 c0       	rjmp	.+142    	; 0xc06 <CheckPins+0x5e6>
			} else {
				if(adcv[0] < 20) {	//Durchlassspannung im gesperrten Zustand gering genug? (sonst werden D-Mode-FETs fälschlicherweise als E-Mode erkannt)
     b78:	2b 81       	ldd	r18, Y+3	; 0x03
     b7a:	3c 81       	ldd	r19, Y+4	; 0x04
     b7c:	24 31       	cpi	r18, 0x14	; 20
     b7e:	31 05       	cpc	r19, r1
     b80:	08 f0       	brcs	.+2      	; 0xb84 <CheckPins+0x564>
     b82:	41 c0       	rjmp	.+130    	; 0xc06 <CheckPins+0x5e6>
					PartFound = PART_FET;			//N-Kanal-MOSFET gefunden (Basis/Gate wird NICHT "nach unten" gezogen)
     b84:	83 e0       	ldi	r24, 0x03	; 3
     b86:	80 93 68 00 	sts	0x0068, r24
					PartMode = PART_MODE_N_E_MOS;
     b8a:	81 e0       	ldi	r24, 0x01	; 1
     b8c:	80 93 67 00 	sts	0x0067, r24
					//Gate-Schwellspannung messen
					tmpval2 = R_DDR;
     b90:	e7 b2       	in	r14, 0x17	; 23
					tmpval=(1<<HighPin);
					ADMUX = TristatePin | (1<<REFS0);
     b92:	8a 2d       	mov	r24, r10
     b94:	80 64       	ori	r24, 0x40	; 64
     b96:	87 b9       	out	0x07, r24	; 7
					gthvoltage = 0;
     b98:	10 92 9a 00 	sts	0x009A, r1
     b9c:	10 92 99 00 	sts	0x0099, r1
					for(b=0;b<13;b++) {
     ba0:	10 92 64 00 	sts	0x0064, r1
     ba4:	1f c0       	rjmp	.+62     	; 0xbe4 <CheckPins+0x5c4>
						wdt_reset();
     ba6:	a8 95       	wdr
						DischargePin(TristatePin,0);
     ba8:	8a 2d       	mov	r24, r10
     baa:	60 e0       	ldi	r22, 0x00	; 0
     bac:	28 db       	rcall	.-2480   	; 0x1fe <DischargePin>
						while ((ADC_PIN&tmpval));  // Warten, bis der MOSFET schaltet und Drain auf low geht
     bae:	83 b3       	in	r24, 0x13	; 19
     bb0:	82 21       	and	r24, r2
     bb2:	e9 f7       	brne	.-6      	; 0xbae <CheckPins+0x58e>
						R_DDR = 0;
     bb4:	17 ba       	out	0x17, r1	; 23
						R_PORT = 0;
     bb6:	18 ba       	out	0x18, r1	; 24
						ADCSRA |= (1<<ADSC);
     bb8:	36 9a       	sbi	0x06, 6	; 6
						while (ADCSRA&(1<<ADSC));
     bba:	36 99       	sbic	0x06, 6	; 6
     bbc:	fe cf       	rjmp	.-4      	; 0xbba <CheckPins+0x59a>
						gthvoltage += ADCW;
     bbe:	24 b1       	in	r18, 0x04	; 4
     bc0:	35 b1       	in	r19, 0x05	; 5
     bc2:	80 91 99 00 	lds	r24, 0x0099
     bc6:	90 91 9a 00 	lds	r25, 0x009A
     bca:	82 0f       	add	r24, r18
     bcc:	93 1f       	adc	r25, r19
     bce:	90 93 9a 00 	sts	0x009A, r25
     bd2:	80 93 99 00 	sts	0x0099, r24
						R_DDR = tmpval2;
     bd6:	e7 ba       	out	0x17, r14	; 23
						R_PORT = tmpval2;
     bd8:	e8 ba       	out	0x18, r14	; 24
					//Gate-Schwellspannung messen
					tmpval2 = R_DDR;
					tmpval=(1<<HighPin);
					ADMUX = TristatePin | (1<<REFS0);
					gthvoltage = 0;
					for(b=0;b<13;b++) {
     bda:	80 91 64 00 	lds	r24, 0x0064
     bde:	8f 5f       	subi	r24, 0xFF	; 255
     be0:	80 93 64 00 	sts	0x0064, r24
     be4:	80 91 64 00 	lds	r24, 0x0064
     be8:	8d 30       	cpi	r24, 0x0D	; 13
     bea:	e8 f2       	brcs	.-70     	; 0xba6 <CheckPins+0x586>
						while (ADCSRA&(1<<ADSC));
						gthvoltage += ADCW;
						R_DDR = tmpval2;
						R_PORT = tmpval2;
					}
					gthvoltage *= 3;	//Umrechnung in mV, zusammen mit der Division durch 8 (bei der LCD-Anzeige)
     bec:	20 91 99 00 	lds	r18, 0x0099
     bf0:	30 91 9a 00 	lds	r19, 0x009A
     bf4:	c9 01       	movw	r24, r18
     bf6:	88 0f       	add	r24, r24
     bf8:	99 1f       	adc	r25, r25
     bfa:	82 0f       	add	r24, r18
     bfc:	93 1f       	adc	r25, r19
     bfe:	90 93 9a 00 	sts	0x009A, r25
     c02:	80 93 99 00 	sts	0x0099, r24
				}
			}
			savenresult:
			b = TristatePin;
     c06:	a0 92 64 00 	sts	0x0064, r10
			c = HighPin;
     c0a:	10 93 83 00 	sts	0x0083, r17
			e = LowPin;
     c0e:	00 93 a2 00 	sts	0x00A2, r16
		}
		ADC_DDR = (1<<TxD);
     c12:	88 e0       	ldi	r24, 0x08	; 8
     c14:	84 bb       	out	0x14, r24	; 20
		ADC_PORT = TXD_VAL;
     c16:	15 ba       	out	0x15, r1	; 21
     c18:	d8 c0       	rjmp	.+432    	; 0xdca <CheckPins+0x7aa>
		//Fertig
	} else {	//Durchgang
		//Test auf Diode
		tmpval2 = (2<<(2*HighPin));	//R_H
     c1a:	e9 80       	ldd	r14, Y+1	; 0x01
     c1c:	fa 80       	ldd	r15, Y+2	; 0x02
     c1e:	ee 0c       	add	r14, r14
     c20:	ff 1c       	adc	r15, r15
     c22:	62 e0       	ldi	r22, 0x02	; 2
     c24:	c6 2e       	mov	r12, r22
     c26:	d1 2c       	mov	r13, r1
     c28:	0e 2c       	mov	r0, r14
     c2a:	02 c0       	rjmp	.+4      	; 0xc30 <CheckPins+0x610>
     c2c:	cc 0c       	add	r12, r12
     c2e:	dd 1c       	adc	r13, r13
     c30:	0a 94       	dec	r0
     c32:	e2 f7       	brpl	.-8      	; 0xc2c <CheckPins+0x60c>
		tmpval = (1<<(2*HighPin));	//R_L
     c34:	81 e0       	ldi	r24, 0x01	; 1
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	ac 01       	movw	r20, r24
     c3a:	02 c0       	rjmp	.+4      	; 0xc40 <CheckPins+0x620>
     c3c:	44 0f       	add	r20, r20
     c3e:	55 1f       	adc	r21, r21
     c40:	ea 94       	dec	r14
     c42:	e2 f7       	brpl	.-8      	; 0xc3c <CheckPins+0x61c>
     c44:	7a 01       	movw	r14, r20
		ADC_PORT = TXD_VAL;
     c46:	15 ba       	out	0x15, r1	; 21
		ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin fest auf Masse, High-Pin ist noch über R_L auf Vcc
     c48:	00 2e       	mov	r0, r16
     c4a:	02 c0       	rjmp	.+4      	; 0xc50 <CheckPins+0x630>
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	0a 94       	dec	r0
     c52:	e2 f7       	brpl	.-8      	; 0xc4c <CheckPins+0x62c>
     c54:	88 60       	ori	r24, 0x08	; 8
     c56:	84 bb       	out	0x14, r24	; 20
		DischargePin(TristatePin,1);	//Entladen für P-Kanal-MOSFET
     c58:	8a 2d       	mov	r24, r10
     c5a:	61 e0       	ldi	r22, 0x01	; 1
     c5c:	d0 da       	rcall	.-2656   	; 0x1fe <DischargePin>
     c5e:	81 ee       	ldi	r24, 0xE1	; 225
     c60:	94 e0       	ldi	r25, 0x04	; 4
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	f1 f7       	brne	.-4      	; 0xc62 <CheckPins+0x642>
     c66:	00 c0       	rjmp	.+0      	; 0xc68 <CheckPins+0x648>
     c68:	00 00       	nop
		_delay_ms(5);
		adcv[0] = ReadADC(HighPin) - ReadADC(LowPin);
     c6a:	81 2f       	mov	r24, r17
     c6c:	b5 da       	rcall	.-2710   	; 0x1d8 <ReadADC>
     c6e:	2c 01       	movw	r4, r24
     c70:	80 2f       	mov	r24, r16
     c72:	b2 da       	rcall	.-2716   	; 0x1d8 <ReadADC>
     c74:	48 1a       	sub	r4, r24
     c76:	59 0a       	sbc	r5, r25
		R_DDR = tmpval2;	//High-Pin über R_H auf Plus
     c78:	c7 ba       	out	0x17, r12	; 23
		R_PORT = tmpval2;
     c7a:	c8 ba       	out	0x18, r12	; 24
     c7c:	e1 ee       	ldi	r30, 0xE1	; 225
     c7e:	f4 e0       	ldi	r31, 0x04	; 4
     c80:	31 97       	sbiw	r30, 0x01	; 1
     c82:	f1 f7       	brne	.-4      	; 0xc80 <CheckPins+0x660>
     c84:	00 c0       	rjmp	.+0      	; 0xc86 <CheckPins+0x666>
     c86:	00 00       	nop
		_delay_ms(5);
		adcv[2] = ReadADC(HighPin) - ReadADC(LowPin);
     c88:	81 2f       	mov	r24, r17
     c8a:	a6 da       	rcall	.-2740   	; 0x1d8 <ReadADC>
     c8c:	4c 01       	movw	r8, r24
     c8e:	80 2f       	mov	r24, r16
     c90:	a3 da       	rcall	.-2746   	; 0x1d8 <ReadADC>
     c92:	3c 01       	movw	r6, r24
		R_DDR = tmpval;	//High-Pin über R_L auf Plus
     c94:	e7 ba       	out	0x17, r14	; 23
		R_PORT = tmpval;
     c96:	e8 ba       	out	0x18, r14	; 24
		DischargePin(TristatePin,0);	//Entladen für N-Kanal-MOSFET
     c98:	8a 2d       	mov	r24, r10
     c9a:	60 e0       	ldi	r22, 0x00	; 0
     c9c:	b0 da       	rcall	.-2720   	; 0x1fe <DischargePin>
     c9e:	81 ee       	ldi	r24, 0xE1	; 225
     ca0:	94 e0       	ldi	r25, 0x04	; 4
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	f1 f7       	brne	.-4      	; 0xca2 <CheckPins+0x682>
     ca6:	00 c0       	rjmp	.+0      	; 0xca8 <CheckPins+0x688>
     ca8:	00 00       	nop
		_delay_ms(5);
		adcv[1] = ReadADC(HighPin) - ReadADC(LowPin);
     caa:	81 2f       	mov	r24, r17
     cac:	95 da       	rcall	.-2774   	; 0x1d8 <ReadADC>
     cae:	7c 01       	movw	r14, r24
     cb0:	80 2f       	mov	r24, r16
     cb2:	92 da       	rcall	.-2780   	; 0x1d8 <ReadADC>
     cb4:	e8 1a       	sub	r14, r24
     cb6:	f9 0a       	sbc	r15, r25
		R_DDR = tmpval2;	//High-Pin über R_H  auf Plus
     cb8:	c7 ba       	out	0x17, r12	; 23
		R_PORT = tmpval2;
     cba:	c8 ba       	out	0x18, r12	; 24
     cbc:	e1 ee       	ldi	r30, 0xE1	; 225
     cbe:	f4 e0       	ldi	r31, 0x04	; 4
     cc0:	31 97       	sbiw	r30, 0x01	; 1
     cc2:	f1 f7       	brne	.-4      	; 0xcc0 <CheckPins+0x6a0>
     cc4:	00 c0       	rjmp	.+0      	; 0xcc6 <CheckPins+0x6a6>
     cc6:	00 00       	nop
		_delay_ms(5);
		adcv[3] = ReadADC(HighPin) - ReadADC(LowPin);
     cc8:	81 2f       	mov	r24, r17
     cca:	86 da       	rcall	.-2804   	; 0x1d8 <ReadADC>
     ccc:	6c 01       	movw	r12, r24
     cce:	80 2f       	mov	r24, r16
     cd0:	83 da       	rcall	.-2810   	; 0x1d8 <ReadADC>
			Die zusätzliche Messung mit dem "großen" Widerstand R_H wird durchgeführt, um antiparallele Dioden von
			Widerständen unterscheiden zu können.
			Eine Diode hat eine vom Durchlassstrom relativ unabhängige Durchlassspg.
			Bei einem Widerstand ändert sich der Spannungsabfall stark (linear) mit dem Strom.
		*/
		if(adcv[0] > adcv[1]) {
     cd2:	e4 14       	cp	r14, r4
     cd4:	f5 04       	cpc	r15, r5
     cd6:	20 f4       	brcc	.+8      	; 0xce0 <CheckPins+0x6c0>
		_delay_ms(5);
		adcv[0] = ReadADC(HighPin) - ReadADC(LowPin);
		R_DDR = tmpval2;	//High-Pin über R_H auf Plus
		R_PORT = tmpval2;
		_delay_ms(5);
		adcv[2] = ReadADC(HighPin) - ReadADC(LowPin);
     cd8:	94 01       	movw	r18, r8
     cda:	26 19       	sub	r18, r6
     cdc:	37 09       	sbc	r19, r7
     cde:	04 c0       	rjmp	.+8      	; 0xce8 <CheckPins+0x6c8>
		_delay_ms(5);
		adcv[1] = ReadADC(HighPin) - ReadADC(LowPin);
		R_DDR = tmpval2;	//High-Pin über R_H  auf Plus
		R_PORT = tmpval2;
		_delay_ms(5);
		adcv[3] = ReadADC(HighPin) - ReadADC(LowPin);
     ce0:	96 01       	movw	r18, r12
     ce2:	28 1b       	sub	r18, r24
     ce4:	39 0b       	sbc	r19, r25
     ce6:	27 01       	movw	r4, r14
		if(adcv[0] > adcv[1]) {
			adcv[1] = adcv[0];	//der höhere Wert gewinnt
			adcv[3] = adcv[2];
		}

		if((adcv[1] > 30) && (adcv[1] < 950)) { //Spannung liegt über 0,15V und unter 4,64V => Ok
     ce8:	c2 01       	movw	r24, r4
     cea:	4f 97       	sbiw	r24, 0x1f	; 31
     cec:	f3 e0       	ldi	r31, 0x03	; 3
     cee:	87 39       	cpi	r24, 0x97	; 151
     cf0:	9f 07       	cpc	r25, r31
     cf2:	08 f0       	brcs	.+2      	; 0xcf6 <CheckPins+0x6d6>
     cf4:	6a c0       	rjmp	.+212    	; 0xdca <CheckPins+0x7aa>
			if((PartFound == PART_NONE) || (PartFound == PART_RESISTOR)) PartFound = PART_DIODE;	//Diode nur angeben, wenn noch kein anderes Bauteil gefunden wurde. Sonst gäbe es Probleme bei Transistoren mit Schutzdiode
     cf6:	80 91 68 00 	lds	r24, 0x0068
     cfa:	88 23       	and	r24, r24
     cfc:	11 f0       	breq	.+4      	; 0xd02 <CheckPins+0x6e2>
     cfe:	86 30       	cpi	r24, 0x06	; 6
     d00:	19 f4       	brne	.+6      	; 0xd08 <CheckPins+0x6e8>
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	80 93 68 00 	sts	0x0068, r24
			diodes[NumOfDiodes].Anode = HighPin;
     d08:	40 91 66 00 	lds	r20, 0x0066
     d0c:	e4 2f       	mov	r30, r20
     d0e:	f0 e0       	ldi	r31, 0x00	; 0
     d10:	ee 0f       	add	r30, r30
     d12:	ff 1f       	adc	r31, r31
     d14:	ee 0f       	add	r30, r30
     d16:	ff 1f       	adc	r31, r31
     d18:	ed 55       	subi	r30, 0x5D	; 93
     d1a:	ff 4f       	sbci	r31, 0xFF	; 255
     d1c:	10 83       	st	Z, r17
			diodes[NumOfDiodes].Cathode = LowPin;
     d1e:	01 83       	std	Z+1, r16	; 0x01
			diodes[NumOfDiodes].Voltage = (adcv[1]*54/11);	// ca. mit 4,9 multiplizieren, um aus dem ADC-Wert die Spannung in Millivolt zu erhalten
     d20:	66 e3       	ldi	r22, 0x36	; 54
     d22:	70 e0       	ldi	r23, 0x00	; 0
     d24:	46 9e       	mul	r4, r22
     d26:	c0 01       	movw	r24, r0
     d28:	47 9e       	mul	r4, r23
     d2a:	90 0d       	add	r25, r0
     d2c:	56 9e       	mul	r5, r22
     d2e:	90 0d       	add	r25, r0
     d30:	11 24       	eor	r1, r1
     d32:	6b e0       	ldi	r22, 0x0B	; 11
     d34:	70 e0       	ldi	r23, 0x00	; 0
     d36:	fd d6       	rcall	.+3578   	; 0x1b32 <__udivmodhi4>
     d38:	73 83       	std	Z+3, r23	; 0x03
     d3a:	62 83       	std	Z+2, r22	; 0x02
			NumOfDiodes++;
     d3c:	4f 5f       	subi	r20, 0xFF	; 255
			for(uint8_t i=0;i<NumOfDiodes;i++) {
				if((diodes[i].Anode == LowPin) && (diodes[i].Cathode == HighPin)) {	//zwei antiparallele Dioden: Defekt oder Duo-LED
					if((adcv[3]*64) < (adcv[1] / 5)) {	//Durchlassspannung fällt bei geringerem Teststrom stark ab => Defekt
     d3e:	96 e0       	ldi	r25, 0x06	; 6
     d40:	22 0f       	add	r18, r18
     d42:	33 1f       	adc	r19, r19
     d44:	9a 95       	dec	r25
     d46:	e1 f7       	brne	.-8      	; 0xd40 <CheckPins+0x720>
     d48:	c2 01       	movw	r24, r4
     d4a:	65 e0       	ldi	r22, 0x05	; 5
     d4c:	70 e0       	ldi	r23, 0x00	; 0
     d4e:	f1 d6       	rcall	.+3554   	; 0x1b32 <__udivmodhi4>
			if((PartFound == PART_NONE) || (PartFound == PART_RESISTOR)) PartFound = PART_DIODE;	//Diode nur angeben, wenn noch kein anderes Bauteil gefunden wurde. Sonst gäbe es Probleme bei Transistoren mit Schutzdiode
			diodes[NumOfDiodes].Anode = HighPin;
			diodes[NumOfDiodes].Cathode = LowPin;
			diodes[NumOfDiodes].Voltage = (adcv[1]*54/11);	// ca. mit 4,9 multiplizieren, um aus dem ADC-Wert die Spannung in Millivolt zu erhalten
			NumOfDiodes++;
			for(uint8_t i=0;i<NumOfDiodes;i++) {
     d50:	50 e0       	ldi	r21, 0x00	; 0
     d52:	37 c0       	rjmp	.+110    	; 0xdc2 <CheckPins+0x7a2>
				if((diodes[i].Anode == LowPin) && (diodes[i].Cathode == HighPin)) {	//zwei antiparallele Dioden: Defekt oder Duo-LED
     d54:	e5 2f       	mov	r30, r21
     d56:	f0 e0       	ldi	r31, 0x00	; 0
     d58:	ee 0f       	add	r30, r30
     d5a:	ff 1f       	adc	r31, r31
     d5c:	ee 0f       	add	r30, r30
     d5e:	ff 1f       	adc	r31, r31
     d60:	ed 55       	subi	r30, 0x5D	; 93
     d62:	ff 4f       	sbci	r31, 0xFF	; 255
     d64:	80 81       	ld	r24, Z
     d66:	80 17       	cp	r24, r16
     d68:	59 f5       	brne	.+86     	; 0xdc0 <CheckPins+0x7a0>
     d6a:	81 81       	ldd	r24, Z+1	; 0x01
     d6c:	81 17       	cp	r24, r17
     d6e:	41 f5       	brne	.+80     	; 0xdc0 <CheckPins+0x7a0>
					if((adcv[3]*64) < (adcv[1] / 5)) {	//Durchlassspannung fällt bei geringerem Teststrom stark ab => Defekt
     d70:	26 17       	cp	r18, r22
     d72:	37 07       	cpc	r19, r23
     d74:	28 f5       	brcc	.+74     	; 0xdc0 <CheckPins+0x7a0>
     d76:	e5 2e       	mov	r14, r21
						if(i<NumOfDiodes) {
							for(uint8_t j=i;j<(NumOfDiodes-1);j++) {
     d78:	84 2f       	mov	r24, r20
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	01 97       	sbiw	r24, 0x01	; 1
     d7e:	1a c0       	rjmp	.+52     	; 0xdb4 <CheckPins+0x794>
								diodes[j].Anode = diodes[j+1].Anode;
     d80:	fd 01       	movw	r30, r26
     d82:	ee 0f       	add	r30, r30
     d84:	ff 1f       	adc	r31, r31
     d86:	ee 0f       	add	r30, r30
     d88:	ff 1f       	adc	r31, r31
     d8a:	ed 55       	subi	r30, 0x5D	; 93
     d8c:	ff 4f       	sbci	r31, 0xFF	; 255
     d8e:	aa 0f       	add	r26, r26
     d90:	bb 1f       	adc	r27, r27
     d92:	aa 0f       	add	r26, r26
     d94:	bb 1f       	adc	r27, r27
     d96:	a9 55       	subi	r26, 0x59	; 89
     d98:	bf 4f       	sbci	r27, 0xFF	; 255
     d9a:	cc 90       	ld	r12, X
     d9c:	c0 82       	st	Z, r12
								diodes[j].Cathode = diodes[j+1].Cathode;
     d9e:	11 96       	adiw	r26, 0x01	; 1
     da0:	cc 90       	ld	r12, X
     da2:	11 97       	sbiw	r26, 0x01	; 1
     da4:	c1 82       	std	Z+1, r12	; 0x01
								diodes[j].Voltage = diodes[j+1].Voltage;
     da6:	12 96       	adiw	r26, 0x02	; 2
     da8:	0d 90       	ld	r0, X+
     daa:	bc 91       	ld	r27, X
     dac:	a0 2d       	mov	r26, r0
     dae:	b3 83       	std	Z+3, r27	; 0x03
     db0:	a2 83       	std	Z+2, r26	; 0x02
			NumOfDiodes++;
			for(uint8_t i=0;i<NumOfDiodes;i++) {
				if((diodes[i].Anode == LowPin) && (diodes[i].Cathode == HighPin)) {	//zwei antiparallele Dioden: Defekt oder Duo-LED
					if((adcv[3]*64) < (adcv[1] / 5)) {	//Durchlassspannung fällt bei geringerem Teststrom stark ab => Defekt
						if(i<NumOfDiodes) {
							for(uint8_t j=i;j<(NumOfDiodes-1);j++) {
     db2:	e3 94       	inc	r14
     db4:	ae 2d       	mov	r26, r14
     db6:	b0 e0       	ldi	r27, 0x00	; 0
     db8:	a8 17       	cp	r26, r24
     dba:	b9 07       	cpc	r27, r25
     dbc:	0c f3       	brlt	.-62     	; 0xd80 <CheckPins+0x760>
								diodes[j].Anode = diodes[j+1].Anode;
								diodes[j].Cathode = diodes[j+1].Cathode;
								diodes[j].Voltage = diodes[j+1].Voltage;
							}
						}
						NumOfDiodes -= 2;
     dbe:	42 50       	subi	r20, 0x02	; 2
			if((PartFound == PART_NONE) || (PartFound == PART_RESISTOR)) PartFound = PART_DIODE;	//Diode nur angeben, wenn noch kein anderes Bauteil gefunden wurde. Sonst gäbe es Probleme bei Transistoren mit Schutzdiode
			diodes[NumOfDiodes].Anode = HighPin;
			diodes[NumOfDiodes].Cathode = LowPin;
			diodes[NumOfDiodes].Voltage = (adcv[1]*54/11);	// ca. mit 4,9 multiplizieren, um aus dem ADC-Wert die Spannung in Millivolt zu erhalten
			NumOfDiodes++;
			for(uint8_t i=0;i<NumOfDiodes;i++) {
     dc0:	5f 5f       	subi	r21, 0xFF	; 255
     dc2:	54 17       	cp	r21, r20
     dc4:	38 f2       	brcs	.-114    	; 0xd54 <CheckPins+0x734>
     dc6:	40 93 66 00 	sts	0x0066, r20
		}
	}

	#ifdef UseM8	//Widerstandsmessung nur auf dem Mega8 verfügbar
		//Test auf Widerstand
		tmpval2 = (2<<(2*HighPin));	//R_H
     dca:	89 81       	ldd	r24, Y+1	; 0x01
     dcc:	9a 81       	ldd	r25, Y+2	; 0x02
     dce:	88 0f       	add	r24, r24
     dd0:	99 1f       	adc	r25, r25
     dd2:	e2 e0       	ldi	r30, 0x02	; 2
     dd4:	ae 2e       	mov	r10, r30
     dd6:	b1 2c       	mov	r11, r1
     dd8:	75 01       	movw	r14, r10
     dda:	08 2e       	mov	r0, r24
     ddc:	02 c0       	rjmp	.+4      	; 0xde2 <CheckPins+0x7c2>
     dde:	ee 0c       	add	r14, r14
     de0:	ff 1c       	adc	r15, r15
     de2:	0a 94       	dec	r0
     de4:	e2 f7       	brpl	.-8      	; 0xdde <CheckPins+0x7be>
		tmpval = (1<<(2*HighPin));	//R_L
     de6:	71 e0       	ldi	r23, 0x01	; 1
     de8:	c7 2e       	mov	r12, r23
     dea:	d1 2c       	mov	r13, r1
     dec:	96 01       	movw	r18, r12
     dee:	02 c0       	rjmp	.+4      	; 0xdf4 <CheckPins+0x7d4>
     df0:	22 0f       	add	r18, r18
     df2:	33 1f       	adc	r19, r19
     df4:	8a 95       	dec	r24
     df6:	e2 f7       	brpl	.-8      	; 0xdf0 <CheckPins+0x7d0>
     df8:	c9 01       	movw	r24, r18
		ADC_PORT = TXD_VAL;
     dfa:	15 ba       	out	0x15, r1	; 21
		ADC_DDR = (1<<LowPin) | (1<<TxD);	//Low-Pin fest auf Masse
     dfc:	40 2e       	mov	r4, r16
     dfe:	55 24       	eor	r5, r5
     e00:	96 01       	movw	r18, r12
     e02:	00 2e       	mov	r0, r16
     e04:	02 c0       	rjmp	.+4      	; 0xe0a <CheckPins+0x7ea>
     e06:	22 0f       	add	r18, r18
     e08:	33 1f       	adc	r19, r19
     e0a:	0a 94       	dec	r0
     e0c:	e2 f7       	brpl	.-8      	; 0xe06 <CheckPins+0x7e6>
     e0e:	28 60       	ori	r18, 0x08	; 8
     e10:	24 bb       	out	0x14, r18	; 20
		R_DDR = tmpval;	//High-Pin über R_L auf Plus
     e12:	87 bb       	out	0x17, r24	; 23
		R_PORT = tmpval;
     e14:	88 bb       	out	0x18, r24	; 24
		adcv[2] = ReadADC(LowPin);
     e16:	80 2f       	mov	r24, r16
     e18:	df d9       	rcall	.-3138   	; 0x1d8 <ReadADC>
     e1a:	4c 01       	movw	r8, r24
		adcv[0] = ReadADC(HighPin) - adcv[2];
     e1c:	81 2f       	mov	r24, r17
     e1e:	dc d9       	rcall	.-3144   	; 0x1d8 <ReadADC>
     e20:	ac 01       	movw	r20, r24
     e22:	48 19       	sub	r20, r8
     e24:	59 09       	sbc	r21, r9
     e26:	5a 83       	std	Y+2, r21	; 0x02
     e28:	49 83       	std	Y+1, r20	; 0x01
		R_DDR = tmpval2;	//High-Pin über R_H auf Plus
     e2a:	e7 ba       	out	0x17, r14	; 23
		R_PORT = tmpval2;
     e2c:	e8 ba       	out	0x18, r14	; 24
		adcv[3] = ReadADC(LowPin);
     e2e:	80 2f       	mov	r24, r16
     e30:	d3 d9       	rcall	.-3162   	; 0x1d8 <ReadADC>
     e32:	3c 01       	movw	r6, r24
		adcv[1] = ReadADC(HighPin) - adcv[3];
     e34:	81 2f       	mov	r24, r17
     e36:	d0 d9       	rcall	.-3168   	; 0x1d8 <ReadADC>
     e38:	7c 01       	movw	r14, r24
     e3a:	e6 18       	sub	r14, r6
     e3c:	f7 08       	sbc	r15, r7

		//Messung der Spannungsdifferenz zwischen dem Pluspol von R_L und R_H und Vcc
		tmpval2 = (2<<(2*LowPin));	//R_H
     e3e:	c2 01       	movw	r24, r4
     e40:	88 0f       	add	r24, r24
     e42:	99 1f       	adc	r25, r25
     e44:	08 2e       	mov	r0, r24
     e46:	02 c0       	rjmp	.+4      	; 0xe4c <CheckPins+0x82c>
     e48:	aa 0c       	add	r10, r10
     e4a:	bb 1c       	adc	r11, r11
     e4c:	0a 94       	dec	r0
     e4e:	e2 f7       	brpl	.-8      	; 0xe48 <CheckPins+0x828>
		tmpval = (1<<(2*LowPin));	//R_L
     e50:	02 c0       	rjmp	.+4      	; 0xe56 <CheckPins+0x836>
     e52:	cc 0c       	add	r12, r12
     e54:	dd 1c       	adc	r13, r13
     e56:	8a 95       	dec	r24
     e58:	e2 f7       	brpl	.-8      	; 0xe52 <CheckPins+0x832>
		ADC_DDR = (1<<HighPin) | (1<<TxD);		//High-Pin auf Ausgang
     e5a:	34 ba       	out	0x14, r3	; 20
		ADC_PORT = (1<<HighPin) | TXD_VAL;	//High-Pin fest auf Plus
     e5c:	25 ba       	out	0x15, r2	; 21
		R_PORT = 0;
     e5e:	18 ba       	out	0x18, r1	; 24
		R_DDR = tmpval;				//Low-Pin über R_L auf Masse
     e60:	c7 ba       	out	0x17, r12	; 23
		adcv[2] += (1023 - ReadADC(HighPin));
     e62:	81 2f       	mov	r24, r17
     e64:	b9 d9       	rcall	.-3214   	; 0x1d8 <ReadADC>
     e66:	6f ef       	ldi	r22, 0xFF	; 255
     e68:	73 e0       	ldi	r23, 0x03	; 3
     e6a:	86 0e       	add	r8, r22
     e6c:	97 1e       	adc	r9, r23
     e6e:	88 1a       	sub	r8, r24
     e70:	99 0a       	sbc	r9, r25
		R_DDR = tmpval2;				//Low-Pin über R_H auf Masse
     e72:	a7 ba       	out	0x17, r10	; 23
		adcv[3] += (1023 - ReadADC(HighPin));
     e74:	81 2f       	mov	r24, r17
     e76:	b0 d9       	rcall	.-3232   	; 0x1d8 <ReadADC>
     e78:	93 01       	movw	r18, r6
     e7a:	21 50       	subi	r18, 0x01	; 1
     e7c:	3c 4f       	sbci	r19, 0xFC	; 252
     e7e:	28 1b       	sub	r18, r24
     e80:	39 0b       	sbc	r19, r25
		
		if(((adcv[0] - adcv[2]) < 900) && ((adcv[1] - adcv[3]) > 20)) goto testend; 	//Spannung fällt bei geringem Teststrom nicht weit genug ab
     e82:	89 81       	ldd	r24, Y+1	; 0x01
     e84:	9a 81       	ldd	r25, Y+2	; 0x02
     e86:	88 19       	sub	r24, r8
     e88:	99 09       	sbc	r25, r9
     e8a:	73 e0       	ldi	r23, 0x03	; 3
     e8c:	84 38       	cpi	r24, 0x84	; 132
     e8e:	97 07       	cpc	r25, r23
     e90:	38 f4       	brcc	.+14     	; 0xea0 <CheckPins+0x880>
     e92:	c7 01       	movw	r24, r14
     e94:	82 1b       	sub	r24, r18
     e96:	93 0b       	sbc	r25, r19
     e98:	85 31       	cpi	r24, 0x15	; 21
     e9a:	91 05       	cpc	r25, r1
     e9c:	08 f0       	brcs	.+2      	; 0xea0 <CheckPins+0x880>
     e9e:	ad c0       	rjmp	.+346    	; 0xffa <CheckPins+0x9da>
		if(((adcv[1] * 32) / 31) < adcv[0]) {	//Abfallende Spannung fällt bei geringerem Teststrom stark ab und es besteht kein "Beinahe-Kurzschluss" => Widerstand
     ea0:	c7 01       	movw	r24, r14
     ea2:	55 e0       	ldi	r21, 0x05	; 5
     ea4:	88 0f       	add	r24, r24
     ea6:	99 1f       	adc	r25, r25
     ea8:	5a 95       	dec	r21
     eaa:	e1 f7       	brne	.-8      	; 0xea4 <CheckPins+0x884>
     eac:	6f e1       	ldi	r22, 0x1F	; 31
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	40 d6       	rcall	.+3200   	; 0x1b32 <__udivmodhi4>
     eb2:	89 81       	ldd	r24, Y+1	; 0x01
     eb4:	9a 81       	ldd	r25, Y+2	; 0x02
     eb6:	68 17       	cp	r22, r24
     eb8:	79 07       	cpc	r23, r25
     eba:	08 f0       	brcs	.+2      	; 0xebe <CheckPins+0x89e>
     ebc:	9e c0       	rjmp	.+316    	; 0xffa <CheckPins+0x9da>
			if((PartFound == PART_DIODE) || (PartFound == PART_NONE) || (PartFound == PART_RESISTOR)) {
     ebe:	80 91 68 00 	lds	r24, 0x0068
     ec2:	82 30       	cpi	r24, 0x02	; 2
     ec4:	18 f0       	brcs	.+6      	; 0xecc <CheckPins+0x8ac>
     ec6:	86 30       	cpi	r24, 0x06	; 6
     ec8:	09 f0       	breq	.+2      	; 0xecc <CheckPins+0x8ac>
     eca:	97 c0       	rjmp	.+302    	; 0xffa <CheckPins+0x9da>
				if((tmpPartFound == PART_RESISTOR) && (ra == LowPin) && (rb == HighPin)) {
     ecc:	e0 91 bb 00 	lds	r30, 0x00BB
     ed0:	e6 30       	cpi	r30, 0x06	; 6
     ed2:	09 f0       	breq	.+2      	; 0xed6 <CheckPins+0x8b6>
     ed4:	72 c0       	rjmp	.+228    	; 0xfba <CheckPins+0x99a>
     ed6:	80 91 bc 00 	lds	r24, 0x00BC
     eda:	80 17       	cp	r24, r16
     edc:	09 f0       	breq	.+2      	; 0xee0 <CheckPins+0x8c0>
     ede:	6d c0       	rjmp	.+218    	; 0xfba <CheckPins+0x99a>
     ee0:	80 91 6f 00 	lds	r24, 0x006F
     ee4:	81 17       	cp	r24, r17
     ee6:	09 f0       	breq	.+2      	; 0xeea <CheckPins+0x8ca>
     ee8:	68 c0       	rjmp	.+208    	; 0xfba <CheckPins+0x99a>
					/* Das Bauteil wurde schon einmal mit umgekehrter Polarität getestet.
					Jetzt beide Ergebnisse miteinander vergleichen. Wenn sie recht ähnlich sind,
					handelt es sich (höchstwahrscheinlich) um einen Widerstand. */
					if(!((((adcv[0] + 100) * 6) >= ((rv[0] + 100) * 5)) && (((rv[0] + 100) * 6) >= ((adcv[0] + 100) * 5)) && (((adcv[1] + 100) * 6) >= ((rv[1] + 100) * 5)) && (((rv[1] + 100) * 6) >= ((adcv[1] + 100) * 5)))) {
     eea:	60 91 94 00 	lds	r22, 0x0094
     eee:	70 91 95 00 	lds	r23, 0x0095
     ef2:	89 81       	ldd	r24, Y+1	; 0x01
     ef4:	9a 81       	ldd	r25, Y+2	; 0x02
     ef6:	88 0f       	add	r24, r24
     ef8:	99 1f       	adc	r25, r25
     efa:	49 81       	ldd	r20, Y+1	; 0x01
     efc:	5a 81       	ldd	r21, Y+2	; 0x02
     efe:	84 0f       	add	r24, r20
     f00:	95 1f       	adc	r25, r21
     f02:	88 0f       	add	r24, r24
     f04:	99 1f       	adc	r25, r25
     f06:	88 5a       	subi	r24, 0xA8	; 168
     f08:	9d 4f       	sbci	r25, 0xFD	; 253
     f0a:	ab 01       	movw	r20, r22
     f0c:	44 0f       	add	r20, r20
     f0e:	55 1f       	adc	r21, r21
     f10:	44 0f       	add	r20, r20
     f12:	55 1f       	adc	r21, r21
     f14:	46 0f       	add	r20, r22
     f16:	57 1f       	adc	r21, r23
     f18:	4c 50       	subi	r20, 0x0C	; 12
     f1a:	5e 4f       	sbci	r21, 0xFE	; 254
     f1c:	84 17       	cp	r24, r20
     f1e:	95 07       	cpc	r25, r21
     f20:	08 f4       	brcc	.+2      	; 0xf24 <CheckPins+0x904>
     f22:	46 c0       	rjmp	.+140    	; 0xfb0 <CheckPins+0x990>
     f24:	cb 01       	movw	r24, r22
     f26:	88 0f       	add	r24, r24
     f28:	99 1f       	adc	r25, r25
     f2a:	86 0f       	add	r24, r22
     f2c:	97 1f       	adc	r25, r23
     f2e:	88 0f       	add	r24, r24
     f30:	99 1f       	adc	r25, r25
     f32:	88 5a       	subi	r24, 0xA8	; 168
     f34:	9d 4f       	sbci	r25, 0xFD	; 253
     f36:	49 81       	ldd	r20, Y+1	; 0x01
     f38:	5a 81       	ldd	r21, Y+2	; 0x02
     f3a:	44 0f       	add	r20, r20
     f3c:	55 1f       	adc	r21, r21
     f3e:	44 0f       	add	r20, r20
     f40:	55 1f       	adc	r21, r21
     f42:	69 81       	ldd	r22, Y+1	; 0x01
     f44:	7a 81       	ldd	r23, Y+2	; 0x02
     f46:	46 0f       	add	r20, r22
     f48:	57 1f       	adc	r21, r23
     f4a:	4c 50       	subi	r20, 0x0C	; 12
     f4c:	5e 4f       	sbci	r21, 0xFE	; 254
     f4e:	84 17       	cp	r24, r20
     f50:	95 07       	cpc	r25, r21
     f52:	70 f1       	brcs	.+92     	; 0xfb0 <CheckPins+0x990>
     f54:	60 91 96 00 	lds	r22, 0x0096
     f58:	70 91 97 00 	lds	r23, 0x0097
     f5c:	c7 01       	movw	r24, r14
     f5e:	88 0f       	add	r24, r24
     f60:	99 1f       	adc	r25, r25
     f62:	8e 0d       	add	r24, r14
     f64:	9f 1d       	adc	r25, r15
     f66:	88 0f       	add	r24, r24
     f68:	99 1f       	adc	r25, r25
     f6a:	88 5a       	subi	r24, 0xA8	; 168
     f6c:	9d 4f       	sbci	r25, 0xFD	; 253
     f6e:	ab 01       	movw	r20, r22
     f70:	44 0f       	add	r20, r20
     f72:	55 1f       	adc	r21, r21
     f74:	44 0f       	add	r20, r20
     f76:	55 1f       	adc	r21, r21
     f78:	46 0f       	add	r20, r22
     f7a:	57 1f       	adc	r21, r23
     f7c:	4c 50       	subi	r20, 0x0C	; 12
     f7e:	5e 4f       	sbci	r21, 0xFE	; 254
     f80:	84 17       	cp	r24, r20
     f82:	95 07       	cpc	r25, r21
     f84:	a8 f0       	brcs	.+42     	; 0xfb0 <CheckPins+0x990>
     f86:	cb 01       	movw	r24, r22
     f88:	88 0f       	add	r24, r24
     f8a:	99 1f       	adc	r25, r25
     f8c:	86 0f       	add	r24, r22
     f8e:	97 1f       	adc	r25, r23
     f90:	88 0f       	add	r24, r24
     f92:	99 1f       	adc	r25, r25
     f94:	88 5a       	subi	r24, 0xA8	; 168
     f96:	9d 4f       	sbci	r25, 0xFD	; 253
     f98:	a7 01       	movw	r20, r14
     f9a:	44 0f       	add	r20, r20
     f9c:	55 1f       	adc	r21, r21
     f9e:	44 0f       	add	r20, r20
     fa0:	55 1f       	adc	r21, r21
     fa2:	4e 0d       	add	r20, r14
     fa4:	5f 1d       	adc	r21, r15
     fa6:	4c 50       	subi	r20, 0x0C	; 12
     fa8:	5e 4f       	sbci	r21, 0xFE	; 254
     faa:	84 17       	cp	r24, r20
     fac:	95 07       	cpc	r25, r21
     fae:	18 f4       	brcc	.+6      	; 0xfb6 <CheckPins+0x996>
						//min. 20% Abweichung => kein Widerstand
						tmpPartFound = PART_NONE;
     fb0:	10 92 bb 00 	sts	0x00BB, r1
						goto testend;
     fb4:	22 c0       	rjmp	.+68     	; 0xffa <CheckPins+0x9da>
					}
					PartFound = PART_RESISTOR;
     fb6:	e0 93 68 00 	sts	0x0068, r30
				}
				rv[0] = adcv[0];
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	9a 81       	ldd	r25, Y+2	; 0x02
     fbe:	90 93 95 00 	sts	0x0095, r25
     fc2:	80 93 94 00 	sts	0x0094, r24
				rv[1] = adcv[1];
     fc6:	f0 92 97 00 	sts	0x0097, r15
     fca:	e0 92 96 00 	sts	0x0096, r14

				radcmax[0] = 1023 - adcv[2];	//Spannung am Low-Pin ist nicht ganz Null, sondern rund 0,1V (wird aber gemessen). Der dadurch entstehende Fehler wird hier kompenisert
     fce:	8f ef       	ldi	r24, 0xFF	; 255
     fd0:	93 e0       	ldi	r25, 0x03	; 3
     fd2:	ac 01       	movw	r20, r24
     fd4:	48 19       	sub	r20, r8
     fd6:	59 09       	sbc	r21, r9
     fd8:	50 93 80 00 	sts	0x0080, r21
     fdc:	40 93 7f 00 	sts	0x007F, r20
				radcmax[1] = 1023 - adcv[3];
     fe0:	82 1b       	sub	r24, r18
     fe2:	93 0b       	sbc	r25, r19
     fe4:	90 93 82 00 	sts	0x0082, r25
     fe8:	80 93 81 00 	sts	0x0081, r24
				ra = HighPin;
     fec:	10 93 bc 00 	sts	0x00BC, r17
				rb = LowPin;
     ff0:	00 93 6f 00 	sts	0x006F, r16
				tmpPartFound = PART_RESISTOR;
     ff4:	86 e0       	ldi	r24, 0x06	; 6
     ff6:	80 93 bb 00 	sts	0x00BB, r24
			}
		}
	#endif
	testend:
	ADC_DDR = (1<<TxD);
     ffa:	88 e0       	ldi	r24, 0x08	; 8
     ffc:	84 bb       	out	0x14, r24	; 20
	ADC_PORT = TXD_VAL;
     ffe:	15 ba       	out	0x15, r1	; 21
	R_DDR = 0;
    1000:	17 ba       	out	0x17, r1	; 23
	R_PORT = 0;
    1002:	18 ba       	out	0x18, r1	; 24
}
    1004:	0f 90       	pop	r0
    1006:	0f 90       	pop	r0
    1008:	0f 90       	pop	r0
    100a:	0f 90       	pop	r0
    100c:	cf 91       	pop	r28
    100e:	df 91       	pop	r29
    1010:	1f 91       	pop	r17
    1012:	0f 91       	pop	r16
    1014:	ff 90       	pop	r15
    1016:	ef 90       	pop	r14
    1018:	df 90       	pop	r13
    101a:	cf 90       	pop	r12
    101c:	bf 90       	pop	r11
    101e:	af 90       	pop	r10
    1020:	9f 90       	pop	r9
    1022:	8f 90       	pop	r8
    1024:	7f 90       	pop	r7
    1026:	6f 90       	pop	r6
    1028:	5f 90       	pop	r5
    102a:	4f 90       	pop	r4
    102c:	3f 90       	pop	r3
    102e:	2f 90       	pop	r2
    1030:	08 95       	ret

00001032 <lcd_show_format_cap>:
	R_DDR &= ~(1<<tmpval);			//Pin wieder auf Eingang
	if(DischargeDirection) R_PORT &= ~(1<<tmpval);			//R_L aus
}

#ifdef UseM8
void lcd_show_format_cap(char outval[], uint8_t strlength, uint8_t CommaPos) {
    1032:	ef 92       	push	r14
    1034:	ff 92       	push	r15
    1036:	0f 93       	push	r16
    1038:	1f 93       	push	r17
    103a:	df 93       	push	r29
    103c:	cf 93       	push	r28
    103e:	0f 92       	push	r0
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	7c 01       	movw	r14, r24
	if(strlength < 3) {
    1046:	63 30       	cpi	r22, 0x03	; 3
    1048:	a0 f4       	brcc	.+40     	; 0x1072 <lcd_show_format_cap+0x40>
		if(strlength==1) {
    104a:	61 30       	cpi	r22, 0x01	; 1
    104c:	41 f4       	brne	.+16     	; 0x105e <lcd_show_format_cap+0x2c>
			lcd_string("0.");
    104e:	80 e6       	ldi	r24, 0x60	; 96
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	a0 d8       	rcall	.-3776   	; 0x194 <lcd_string>
			lcd_data('0');
    1054:	80 e3       	ldi	r24, 0x30	; 48
    1056:	2f d8       	rcall	.-4002   	; 0xb6 <lcd_data>
			lcd_data(outval[0]);
    1058:	f7 01       	movw	r30, r14
    105a:	80 81       	ld	r24, Z
    105c:	08 c0       	rjmp	.+16     	; 0x106e <lcd_show_format_cap+0x3c>
		} else {
			lcd_string("0.");
    105e:	80 e6       	ldi	r24, 0x60	; 96
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	98 d8       	rcall	.-3792   	; 0x194 <lcd_string>
			lcd_data(outval[0]);
    1064:	f7 01       	movw	r30, r14
    1066:	80 81       	ld	r24, Z
    1068:	26 d8       	rcall	.-4020   	; 0xb6 <lcd_data>
			lcd_data(outval[1]);
    106a:	f7 01       	movw	r30, r14
    106c:	81 81       	ldd	r24, Z+1	; 0x01
    106e:	23 d8       	rcall	.-4026   	; 0xb6 <lcd_data>
    1070:	20 c0       	rjmp	.+64     	; 0x10b2 <lcd_show_format_cap+0x80>
		}
	} else {
		for(PartReady=0;PartReady<strlength;PartReady++) {
    1072:	10 92 65 00 	sts	0x0065, r1
			if((PartReady + 2) == CommaPos) lcd_data('.');
    1076:	04 2f       	mov	r16, r20
    1078:	10 e0       	ldi	r17, 0x00	; 0
			lcd_string("0.");
			lcd_data(outval[0]);
			lcd_data(outval[1]);
		}
	} else {
		for(PartReady=0;PartReady<strlength;PartReady++) {
    107a:	17 c0       	rjmp	.+46     	; 0x10aa <lcd_show_format_cap+0x78>
			if((PartReady + 2) == CommaPos) lcd_data('.');
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	02 96       	adiw	r24, 0x02	; 2
    1080:	80 17       	cp	r24, r16
    1082:	91 07       	cpc	r25, r17
    1084:	21 f4       	brne	.+8      	; 0x108e <lcd_show_format_cap+0x5c>
    1086:	8e e2       	ldi	r24, 0x2E	; 46
    1088:	69 83       	std	Y+1, r22	; 0x01
    108a:	15 d8       	rcall	.-4054   	; 0xb6 <lcd_data>
    108c:	69 81       	ldd	r22, Y+1	; 0x01
			lcd_data(outval[PartReady]);
    108e:	80 91 65 00 	lds	r24, 0x0065
    1092:	f7 01       	movw	r30, r14
    1094:	e8 0f       	add	r30, r24
    1096:	f1 1d       	adc	r31, r1
    1098:	80 81       	ld	r24, Z
    109a:	69 83       	std	Y+1, r22	; 0x01
    109c:	0c d8       	rcall	.-4072   	; 0xb6 <lcd_data>
			lcd_string("0.");
			lcd_data(outval[0]);
			lcd_data(outval[1]);
		}
	} else {
		for(PartReady=0;PartReady<strlength;PartReady++) {
    109e:	80 91 65 00 	lds	r24, 0x0065
    10a2:	8f 5f       	subi	r24, 0xFF	; 255
    10a4:	80 93 65 00 	sts	0x0065, r24
    10a8:	69 81       	ldd	r22, Y+1	; 0x01
    10aa:	80 91 65 00 	lds	r24, 0x0065
    10ae:	86 17       	cp	r24, r22
    10b0:	28 f3       	brcs	.-54     	; 0x107c <lcd_show_format_cap+0x4a>
			if((PartReady + 2) == CommaPos) lcd_data('.');
			lcd_data(outval[PartReady]);
		}
	}
}
    10b2:	0f 90       	pop	r0
    10b4:	cf 91       	pop	r28
    10b6:	df 91       	pop	r29
    10b8:	1f 91       	pop	r17
    10ba:	0f 91       	pop	r16
    10bc:	ff 90       	pop	r15
    10be:	ef 90       	pop	r14
    10c0:	08 95       	ret

000010c2 <main>:
#ifdef UseM8
	char outval2[6];
#endif

//Programmbeginn
int main(void) {
    10c2:	2f 92       	push	r2
    10c4:	3f 92       	push	r3
    10c6:	4f 92       	push	r4
    10c8:	5f 92       	push	r5
    10ca:	6f 92       	push	r6
    10cc:	7f 92       	push	r7
    10ce:	8f 92       	push	r8
    10d0:	9f 92       	push	r9
    10d2:	af 92       	push	r10
    10d4:	bf 92       	push	r11
    10d6:	cf 92       	push	r12
    10d8:	df 92       	push	r13
    10da:	ef 92       	push	r14
    10dc:	ff 92       	push	r15
    10de:	0f 93       	push	r16
    10e0:	1f 93       	push	r17
    10e2:	cf 93       	push	r28
    10e4:	df 93       	push	r29
	//Einschalten
	ON_DDR = (1<<ON_PIN);
    10e6:	80 e4       	ldi	r24, 0x40	; 64
    10e8:	81 bb       	out	0x11, r24	; 17
	ON_PORT = (1<<ON_PIN) | (1<<RST_PIN);	//Strom an und Pullup für Reset-Pin
    10ea:	80 ec       	ldi	r24, 0xC0	; 192
    10ec:	82 bb       	out	0x12, r24	; 18
	uint8_t tmp;
	//ADC-Init
	ADCSRA = (1<<ADEN) | (1<<ADPS1) | (1<<ADPS0);	//Vorteiler=8
    10ee:	83 e8       	ldi	r24, 0x83	; 131
    10f0:	86 b9       	out	0x06, r24	; 6
	lcd_init();
    10f2:	15 d8       	rcall	.-4054   	; 0x11e <lcd_init>
	
	#ifdef UseM8
		//Konstanten aus EEPROM laden
		unsigned int rhval = eeprom_read_word(&R_H_VAL);	//R_H
    10f4:	86 e0       	ldi	r24, 0x06	; 6
    10f6:	90 e0       	ldi	r25, 0x00	; 0
    10f8:	b0 d5       	rcall	.+2912   	; 0x1c5a <__eerd_word_m8>
    10fa:	ec 01       	movw	r28, r24
		unsigned int rlval = eeprom_read_word(&R_L_VAL);	//R_L
    10fc:	84 e0       	ldi	r24, 0x04	; 4
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	ac d5       	rcall	.+2904   	; 0x1c5a <__eerd_word_m8>
    1102:	5c 01       	movw	r10, r24
		ctmode = eeprom_read_byte(&CapTestMode);
    1104:	80 e0       	ldi	r24, 0x00	; 0
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	a0 d5       	rcall	.+2880   	; 0x1c4a <__eerd_byte_m8>
		cp1 = (ctmode & 12) >> 2;
    110a:	48 2f       	mov	r20, r24
    110c:	50 e0       	ldi	r21, 0x00	; 0
    110e:	9a 01       	movw	r18, r20
    1110:	2c 70       	andi	r18, 0x0C	; 12
    1112:	30 70       	andi	r19, 0x00	; 0
    1114:	35 95       	asr	r19
    1116:	27 95       	ror	r18
    1118:	35 95       	asr	r19
    111a:	27 95       	ror	r18
    111c:	20 93 a0 00 	sts	0x00A0, r18
		cp2 = ctmode & 3;
    1120:	83 70       	andi	r24, 0x03	; 3
    1122:	80 93 98 00 	sts	0x0098, r24
		ctmode = (ctmode & 48) >> 4;
    1126:	ca 01       	movw	r24, r20
    1128:	80 73       	andi	r24, 0x30	; 48
    112a:	90 70       	andi	r25, 0x00	; 0
    112c:	04 e0       	ldi	r16, 0x04	; 4
    112e:	95 95       	asr	r25
    1130:	87 95       	ror	r24
    1132:	0a 95       	dec	r16
    1134:	e1 f7       	brne	.-8      	; 0x112e <main+0x6c>
    1136:	80 93 a1 00 	sts	0x00A1, r24
	#endif

	wdt_disable();
    113a:	88 e1       	ldi	r24, 0x18	; 24
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	81 bd       	out	0x21, r24	; 33
    1142:	11 bc       	out	0x21, r1	; 33
    1144:	0f be       	out	0x3f, r0	; 63
	if(MCU_STATUS_REG & (1<<WDRF)) {	
    1146:	04 b6       	in	r0, 0x34	; 52
    1148:	03 fe       	sbrs	r0, 3
    114a:	0b c0       	rjmp	.+22     	; 0x1162 <main+0xa0>
		/*
		Überprüfen auf Watchdog-Reset 
		Das tritt ein, wenn der Watchdog 2s nicht zurückgesetzt wurde
		Kann vorkommen, wenn sich das Programm in einer Endlosschleife "verheddert" hat.
		*/
		lcd_eep_string(TestTimedOut);	//Timeout-Meldung
    114c:	8e e4       	ldi	r24, 0x4E	; 78
    114e:	91 e0       	ldi	r25, 0x01	; 1
    1150:	34 d8       	rcall	.-3992   	; 0x1ba <lcd_eep_string>
    1152:	8f eb       	ldi	r24, 0xBF	; 191
    1154:	97 e2       	ldi	r25, 0x27	; 39
    1156:	a9 e0       	ldi	r26, 0x09	; 9
    1158:	81 50       	subi	r24, 0x01	; 1
    115a:	90 40       	sbci	r25, 0x00	; 0
    115c:	a0 40       	sbci	r26, 0x00	; 0
    115e:	e1 f7       	brne	.-8      	; 0x1158 <main+0x96>
    1160:	54 c0       	rjmp	.+168    	; 0x120a <main+0x148>
		_delay_ms(3000);
		ON_PORT = 0;	//Abschalten!
		return 0;
	}
	LCDLoadCustomChar();	//Custom-Zeichen
    1162:	80 e4       	ldi	r24, 0x40	; 64
    1164:	c7 d7       	rcall	.+3982   	; 0x20f4 <__data_load_end+0x448>
	//Diodensymbol in LCD laden
	lcd_eep_string(DiodeIcon);
    1166:	87 e5       	ldi	r24, 0x57	; 87
    1168:	91 e0       	ldi	r25, 0x01	; 1
    116a:	27 d8       	rcall	.-4018   	; 0x1ba <lcd_eep_string>
	Line1();	//1. Zeile
    116c:	80 e8       	ldi	r24, 0x80	; 128
    116e:	c2 d7       	rcall	.+3972   	; 0x20f4 <__data_load_end+0x448>
		//Verstärkungsfaktor berechnen
		//hFE = Emitterstrom / Basisstrom
		lhfe = hfe[1];

		#ifdef UseM8
			lhfe *= (((unsigned long)rhval * 100) / (unsigned long)rlval);	//Verhältnis von High- zu Low-Widerstand
    1170:	be 01       	movw	r22, r28
    1172:	80 e0       	ldi	r24, 0x00	; 0
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	24 e6       	ldi	r18, 0x64	; 100
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	40 e0       	ldi	r20, 0x00	; 0
    117c:	50 e0       	ldi	r21, 0x00	; 0
    117e:	ba d4       	rcall	.+2420   	; 0x1af4 <__mulsi3>
    1180:	3b 01       	movw	r6, r22
    1182:	4c 01       	movw	r8, r24
			tmpval2 = 'n';
			if(cv > 99999) {	//ab 1µF
				cv /= 1000;
				tmpval2 = LCD_CHAR_U;
			}
			ultoa(cv, outval, 10);
    1184:	10 e7       	ldi	r17, 0x70	; 112
    1186:	c1 2e       	mov	r12, r17
    1188:	10 e0       	ldi	r17, 0x00	; 0
    118a:	d1 2e       	mov	r13, r17
		//Verstärkungsfaktor berechnen
		//hFE = Emitterstrom / Basisstrom
		lhfe = hfe[1];

		#ifdef UseM8
			lhfe *= (((unsigned long)rhval * 100) / (unsigned long)rlval);	//Verhältnis von High- zu Low-Widerstand
    118c:	15 01       	movw	r2, r10
    118e:	44 24       	eor	r4, r4
    1190:	55 24       	eor	r5, r5
	lcd_eep_string(DiodeIcon);
	Line1();	//1. Zeile
	//Einsprungspunkt, wenn Start-Taste im Betrieb erneut gedrückt wird
	start:
	#ifdef WDT_enabled
		wdt_enable(WDTO_2S);	//Watchdog an
    1192:	2f e0       	ldi	r18, 0x0F	; 15
    1194:	88 e1       	ldi	r24, 0x18	; 24
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	a8 95       	wdr
    119e:	81 bd       	out	0x21, r24	; 33
    11a0:	0f be       	out	0x3f, r0	; 63
    11a2:	21 bd       	out	0x21, r18	; 33
	#endif
	PartFound = PART_NONE;
    11a4:	10 92 68 00 	sts	0x0068, r1
	tmpPartFound = PART_NONE;
    11a8:	10 92 bb 00 	sts	0x00BB, r1
	NumOfDiodes = 0;
    11ac:	10 92 66 00 	sts	0x0066, r1
	PartReady = 0;
    11b0:	10 92 65 00 	sts	0x0065, r1
	PartMode = 0;
    11b4:	10 92 67 00 	sts	0x0067, r1
	#ifdef UseM8
	ca = 0;
    11b8:	10 92 9b 00 	sts	0x009B, r1
	cb = 0;
    11bc:	10 92 69 00 	sts	0x0069, r1
	#endif
	lcd_clear();
    11c0:	a4 d7       	rcall	.+3912   	; 0x210a <__data_load_end+0x45e>
	ADC_DDR = (1<<TxD);	//Software-UART aktivieren
    11c2:	88 e0       	ldi	r24, 0x08	; 8
    11c4:	84 bb       	out	0x14, r24	; 20
	uart_newline();
    11c6:	91 d7       	rcall	.+3874   	; 0x20ea <__data_load_end+0x43e>
	//Versorgungsspannung messen
	ReadADC(5 | (1<<REFS1));	//Dummy-Readout
    11c8:	85 e8       	ldi	r24, 0x85	; 133
    11ca:	06 d8       	rcall	.-4084   	; 0x1d8 <ReadADC>
	hfe[0] = ReadADC(5 | (1<<REFS1)); 	//mit interner Referenz
    11cc:	85 e8       	ldi	r24, 0x85	; 133
    11ce:	04 d8       	rcall	.-4088   	; 0x1d8 <ReadADC>
    11d0:	90 93 9d 00 	sts	0x009D, r25
    11d4:	80 93 9c 00 	sts	0x009C, r24
	if (hfe[0] < 650) {			//Vcc < 7,6V; Warnung anzeigen
    11d8:	a2 e0       	ldi	r26, 0x02	; 2
    11da:	8a 38       	cpi	r24, 0x8A	; 138
    11dc:	9a 07       	cpc	r25, r26
    11de:	90 f5       	brcc	.+100    	; 0x1244 <main+0x182>
		lcd_eep_string(Bat);		//Anzeige: "Batterie"
    11e0:	8c e1       	ldi	r24, 0x1C	; 28
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	ea d7       	rcall	.+4052   	; 0x21ba <__data_load_end+0x50e>
		if(hfe[0] < 600) {					//Vcc <7,15V; zuverlässiger Betrieb nicht mehr möglich
    11e6:	80 91 9c 00 	lds	r24, 0x009C
    11ea:	90 91 9d 00 	lds	r25, 0x009D
    11ee:	b2 e0       	ldi	r27, 0x02	; 2
    11f0:	88 35       	cpi	r24, 0x58	; 88
    11f2:	9b 07       	cpc	r25, r27
    11f4:	10 f5       	brcc	.+68     	; 0x123a <main+0x178>
			lcd_eep_string(BatEmpty);		//Batterie leer!
    11f6:	8d e2       	ldi	r24, 0x2D	; 45
    11f8:	90 e0       	ldi	r25, 0x00	; 0
    11fa:	df d7       	rcall	.+4030   	; 0x21ba <__data_load_end+0x50e>
    11fc:	8f e3       	ldi	r24, 0x3F	; 63
    11fe:	9d e0       	ldi	r25, 0x0D	; 13
    1200:	a3 e0       	ldi	r26, 0x03	; 3
    1202:	81 50       	subi	r24, 0x01	; 1
    1204:	90 40       	sbci	r25, 0x00	; 0
    1206:	a0 40       	sbci	r26, 0x00	; 0
    1208:	e1 f7       	brne	.-8      	; 0x1202 <main+0x140>
    120a:	00 c0       	rjmp	.+0      	; 0x120c <main+0x14a>
    120c:	00 00       	nop
			_delay_ms(1000);
			PORTD = 0;	//abschalten
    120e:	12 ba       	out	0x12, r1	; 18
		 	wenn die automatische Abschaltung nicht eingebaut wurde */
			goto start;
		}
	}
	return 0;
}
    1210:	80 e0       	ldi	r24, 0x00	; 0
    1212:	90 e0       	ldi	r25, 0x00	; 0
    1214:	df 91       	pop	r29
    1216:	cf 91       	pop	r28
    1218:	1f 91       	pop	r17
    121a:	0f 91       	pop	r16
    121c:	ff 90       	pop	r15
    121e:	ef 90       	pop	r14
    1220:	df 90       	pop	r13
    1222:	cf 90       	pop	r12
    1224:	bf 90       	pop	r11
    1226:	af 90       	pop	r10
    1228:	9f 90       	pop	r9
    122a:	8f 90       	pop	r8
    122c:	7f 90       	pop	r7
    122e:	6f 90       	pop	r6
    1230:	5f 90       	pop	r5
    1232:	4f 90       	pop	r4
    1234:	3f 90       	pop	r3
    1236:	2f 90       	pop	r2
    1238:	08 95       	ret
			lcd_eep_string(BatEmpty);		//Batterie leer!
			_delay_ms(1000);
			PORTD = 0;	//abschalten
			return 0;
		}
		lcd_eep_string(BatWeak);		//Batterie schwach
    123a:	8d e1       	ldi	r24, 0x1D	; 29
    123c:	90 e0       	ldi	r25, 0x00	; 0
    123e:	bd d7       	rcall	.+3962   	; 0x21ba <__data_load_end+0x50e>
		Line2();
    1240:	80 ec       	ldi	r24, 0xC0	; 192
    1242:	58 d7       	rcall	.+3760   	; 0x20f4 <__data_load_end+0x448>
	}
	//Test beginnen
	lcd_eep_string(TestRunning);	//String: Test läuft
    1244:	8c e0       	ldi	r24, 0x0C	; 12
    1246:	90 e0       	ldi	r25, 0x00	; 0
    1248:	b8 d7       	rcall	.+3952   	; 0x21ba <__data_load_end+0x50e>
	//Alle 6 Kombinationsmöglichkeiten für die 3 Pins prüfen
	CheckPins(TP1, TP2, TP3);
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	61 e0       	ldi	r22, 0x01	; 1
    124e:	42 e0       	ldi	r20, 0x02	; 2
    1250:	e7 d9       	rcall	.-3122   	; 0x620 <CheckPins>
	CheckPins(TP1, TP3, TP2);
    1252:	80 e0       	ldi	r24, 0x00	; 0
    1254:	62 e0       	ldi	r22, 0x02	; 2
    1256:	41 e0       	ldi	r20, 0x01	; 1
    1258:	e3 d9       	rcall	.-3130   	; 0x620 <CheckPins>
	CheckPins(TP2, TP1, TP3);
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	60 e0       	ldi	r22, 0x00	; 0
    125e:	42 e0       	ldi	r20, 0x02	; 2
    1260:	df d9       	rcall	.-3138   	; 0x620 <CheckPins>
	CheckPins(TP2, TP3, TP1);
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	62 e0       	ldi	r22, 0x02	; 2
    1266:	40 e0       	ldi	r20, 0x00	; 0
    1268:	db d9       	rcall	.-3146   	; 0x620 <CheckPins>
	CheckPins(TP3, TP2, TP1);
    126a:	82 e0       	ldi	r24, 0x02	; 2
    126c:	61 e0       	ldi	r22, 0x01	; 1
    126e:	40 e0       	ldi	r20, 0x00	; 0
    1270:	d7 d9       	rcall	.-3154   	; 0x620 <CheckPins>
	CheckPins(TP3, TP1, TP2);
    1272:	82 e0       	ldi	r24, 0x02	; 2
    1274:	60 e0       	ldi	r22, 0x00	; 0
    1276:	41 e0       	ldi	r20, 0x01	; 1
    1278:	d3 d9       	rcall	.-3162   	; 0x620 <CheckPins>
	#ifdef UseM8
		//Separate Messung zum Test auf Kondensator
		if(((PartFound == PART_NONE) || (PartFound == PART_RESISTOR) || (PartFound == PART_DIODE)) && (ctmode > 0)) {
    127a:	80 91 68 00 	lds	r24, 0x0068
    127e:	88 23       	and	r24, r24
    1280:	21 f0       	breq	.+8      	; 0x128a <main+0x1c8>
    1282:	86 30       	cpi	r24, 0x06	; 6
    1284:	11 f0       	breq	.+4      	; 0x128a <main+0x1c8>
    1286:	81 30       	cpi	r24, 0x01	; 1
    1288:	61 f5       	brne	.+88     	; 0x12e2 <main+0x220>
    128a:	80 91 a1 00 	lds	r24, 0x00A1
    128e:	88 23       	and	r24, r24
    1290:	41 f1       	breq	.+80     	; 0x12e2 <main+0x220>
			//Kondensator entladen; sonst ist evtl. keine Messung möglich
			R_PORT = 0;
    1292:	18 ba       	out	0x18, r1	; 24
			R_DDR = (1<<(TP1 * 2)) | (1<<(TP2 * 2)) | (1<<(TP3 * 2));
    1294:	95 e1       	ldi	r25, 0x15	; 21
    1296:	97 bb       	out	0x17, r25	; 23
    1298:	a3 ec       	ldi	r26, 0xC3	; 195
    129a:	b9 e0       	ldi	r27, 0x09	; 9
    129c:	11 97       	sbiw	r26, 0x01	; 1
    129e:	f1 f7       	brne	.-4      	; 0x129c <main+0x1da>
    12a0:	00 c0       	rjmp	.+0      	; 0x12a2 <main+0x1e0>
    12a2:	00 00       	nop
			_delay_ms(10);
			R_DDR = 0;
    12a4:	17 ba       	out	0x17, r1	; 23
			//Kapazität in allen 6 Pin-Kombinationen messen
			if(ctmode == 1) {
    12a6:	81 30       	cpi	r24, 0x01	; 1
    12a8:	51 f4       	brne	.+20     	; 0x12be <main+0x1fc>
				ReadCapacity(cp1, cp2);
    12aa:	80 91 a0 00 	lds	r24, 0x00A0
    12ae:	60 91 98 00 	lds	r22, 0x0098
    12b2:	cd d7       	rcall	.+3994   	; 0x224e <__data_load_end+0x5a2>
				ReadCapacity(cp2, cp1);
    12b4:	80 91 98 00 	lds	r24, 0x0098
    12b8:	60 91 a0 00 	lds	r22, 0x00A0
    12bc:	11 c0       	rjmp	.+34     	; 0x12e0 <main+0x21e>
			} else {
				ReadCapacity(TP3, TP1);
    12be:	82 e0       	ldi	r24, 0x02	; 2
    12c0:	60 e0       	ldi	r22, 0x00	; 0
    12c2:	c5 d7       	rcall	.+3978   	; 0x224e <__data_load_end+0x5a2>
				ReadCapacity(TP3, TP2);
    12c4:	82 e0       	ldi	r24, 0x02	; 2
    12c6:	61 e0       	ldi	r22, 0x01	; 1
    12c8:	c2 d7       	rcall	.+3972   	; 0x224e <__data_load_end+0x5a2>
				ReadCapacity(TP2, TP3);
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	62 e0       	ldi	r22, 0x02	; 2
    12ce:	bf d7       	rcall	.+3966   	; 0x224e <__data_load_end+0x5a2>
				ReadCapacity(TP2, TP1);
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	60 e0       	ldi	r22, 0x00	; 0
    12d4:	bc d7       	rcall	.+3960   	; 0x224e <__data_load_end+0x5a2>
				ReadCapacity(TP1, TP3);
    12d6:	80 e0       	ldi	r24, 0x00	; 0
    12d8:	62 e0       	ldi	r22, 0x02	; 2
    12da:	b9 d7       	rcall	.+3954   	; 0x224e <__data_load_end+0x5a2>
				ReadCapacity(TP1, TP2);
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	61 e0       	ldi	r22, 0x01	; 1
    12e0:	b6 d7       	rcall	.+3948   	; 0x224e <__data_load_end+0x5a2>
			}
		}
	#endif
	//Fertig, jetzt folgt die Auswertung
	lcd_clear();
    12e2:	13 d7       	rcall	.+3622   	; 0x210a <__data_load_end+0x45e>
	if(PartFound == PART_DIODE) {
    12e4:	80 91 68 00 	lds	r24, 0x0068
    12e8:	81 30       	cpi	r24, 0x01	; 1
    12ea:	09 f0       	breq	.+2      	; 0x12ee <main+0x22c>
    12ec:	c0 c0       	rjmp	.+384    	; 0x146e <main+0x3ac>
		if(NumOfDiodes == 1) {
    12ee:	80 91 66 00 	lds	r24, 0x0066
    12f2:	81 30       	cpi	r24, 0x01	; 1
    12f4:	19 f5       	brne	.+70     	; 0x133c <main+0x27a>
			//Standard-Diode
			lcd_eep_string(Diode);	//"Diode: "
    12f6:	82 e7       	ldi	r24, 0x72	; 114
    12f8:	90 e0       	ldi	r25, 0x00	; 0
    12fa:	5f d7       	rcall	.+3774   	; 0x21ba <__data_load_end+0x50e>
			lcd_eep_string(Anode);
    12fc:	82 e4       	ldi	r24, 0x42	; 66
    12fe:	91 e0       	ldi	r25, 0x01	; 1
    1300:	5c d7       	rcall	.+3768   	; 0x21ba <__data_load_end+0x50e>
			lcd_data(diodes[0].Anode + 49);
    1302:	80 91 a3 00 	lds	r24, 0x00A3
    1306:	8f 5c       	subi	r24, 0xCF	; 207
    1308:	d6 d6       	rcall	.+3500   	; 0x20b6 <__data_load_end+0x40a>
			lcd_eep_string(NextK);//";K="
    130a:	88 eb       	ldi	r24, 0xB8	; 184
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	55 d7       	rcall	.+3754   	; 0x21ba <__data_load_end+0x50e>
			lcd_data(diodes[0].Cathode + 49);
    1310:	80 91 a4 00 	lds	r24, 0x00A4
    1314:	8f 5c       	subi	r24, 0xCF	; 207
    1316:	cf d6       	rcall	.+3486   	; 0x20b6 <__data_load_end+0x40a>
			Line2();	//2. Zeile
    1318:	80 ec       	ldi	r24, 0xC0	; 192
    131a:	ec d6       	rcall	.+3544   	; 0x20f4 <__data_load_end+0x448>
			lcd_eep_string(Uf);	//"Uf = "
    131c:	87 e3       	ldi	r24, 0x37	; 55
    131e:	91 e0       	ldi	r25, 0x01	; 1
    1320:	4c d7       	rcall	.+3736   	; 0x21ba <__data_load_end+0x50e>
			lcd_string(itoa(diodes[0].Voltage, outval, 10));
    1322:	80 91 a5 00 	lds	r24, 0x00A5
    1326:	90 91 a6 00 	lds	r25, 0x00A6
    132a:	60 e7       	ldi	r22, 0x70	; 112
    132c:	70 e0       	ldi	r23, 0x00	; 0
    132e:	4a e0       	ldi	r20, 0x0A	; 10
    1330:	50 e0       	ldi	r21, 0x00	; 0
    1332:	35 d4       	rcall	.+2154   	; 0x1b9e <itoa>
    1334:	2f d7       	rcall	.+3678   	; 0x2194 <__data_load_end+0x4e8>
			lcd_eep_string(mV);
    1336:	8f e3       	ldi	r24, 0x3F	; 63
    1338:	91 e0       	ldi	r25, 0x01	; 1
    133a:	7c c3       	rjmp	.+1784   	; 0x1a34 <main+0x972>
			goto end;
		} else if(NumOfDiodes == 2) {
    133c:	82 30       	cpi	r24, 0x02	; 2
    133e:	09 f0       	breq	.+2      	; 0x1342 <main+0x280>
    1340:	52 c0       	rjmp	.+164    	; 0x13e6 <main+0x324>
		//Doppeldiode
			if(diodes[0].Anode == diodes[1].Anode) {
    1342:	80 91 a3 00 	lds	r24, 0x00A3
    1346:	20 91 a7 00 	lds	r18, 0x00A7
    134a:	82 17       	cp	r24, r18
    134c:	e1 f4       	brne	.+56     	; 0x1386 <main+0x2c4>
				//Common Anode
				lcd_eep_string(DualDiode);	//Doppeldiode
    134e:	89 e7       	ldi	r24, 0x79	; 121
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	33 d7       	rcall	.+3686   	; 0x21ba <__data_load_end+0x50e>
				lcd_eep_string(CA);	//"CA"
    1354:	88 e4       	ldi	r24, 0x48	; 72
    1356:	91 e0       	ldi	r25, 0x01	; 1
    1358:	30 d7       	rcall	.+3680   	; 0x21ba <__data_load_end+0x50e>
				Line2(); //2. Zeile
    135a:	80 ec       	ldi	r24, 0xC0	; 192
    135c:	cb d6       	rcall	.+3478   	; 0x20f4 <__data_load_end+0x448>
				lcd_eep_string(Anode);
    135e:	82 e4       	ldi	r24, 0x42	; 66
    1360:	91 e0       	ldi	r25, 0x01	; 1
    1362:	2b d7       	rcall	.+3670   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(diodes[0].Anode + 49);
    1364:	80 91 a3 00 	lds	r24, 0x00A3
    1368:	8f 5c       	subi	r24, 0xCF	; 207
    136a:	a5 d6       	rcall	.+3402   	; 0x20b6 <__data_load_end+0x40a>
				lcd_eep_string(K1);	//";K1="
    136c:	89 ea       	ldi	r24, 0xA9	; 169
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	24 d7       	rcall	.+3656   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(diodes[0].Cathode + 49);
    1372:	80 91 a4 00 	lds	r24, 0x00A4
    1376:	8f 5c       	subi	r24, 0xCF	; 207
    1378:	9e d6       	rcall	.+3388   	; 0x20b6 <__data_load_end+0x40a>
				lcd_eep_string(K2);	//";K2="
    137a:	8e ea       	ldi	r24, 0xAE	; 174
    137c:	90 e0       	ldi	r25, 0x00	; 0
    137e:	1d d7       	rcall	.+3642   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(diodes[1].Cathode + 49);
    1380:	80 91 a8 00 	lds	r24, 0x00A8
    1384:	22 c2       	rjmp	.+1092   	; 0x17ca <main+0x708>
				goto end;
			} else if(diodes[0].Cathode == diodes[1].Cathode) {
    1386:	30 91 a4 00 	lds	r19, 0x00A4
    138a:	90 91 a8 00 	lds	r25, 0x00A8
    138e:	39 17       	cp	r19, r25
    1390:	e1 f4       	brne	.+56     	; 0x13ca <main+0x308>
				//Common Cathode
				lcd_eep_string(DualDiode);	//Doppeldiode
    1392:	89 e7       	ldi	r24, 0x79	; 121
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	11 d7       	rcall	.+3618   	; 0x21ba <__data_load_end+0x50e>
				lcd_eep_string(CC);	//"CC"
    1398:	8b e4       	ldi	r24, 0x4B	; 75
    139a:	91 e0       	ldi	r25, 0x01	; 1
    139c:	0e d7       	rcall	.+3612   	; 0x21ba <__data_load_end+0x50e>
				Line2(); //2. Zeile
    139e:	80 ec       	ldi	r24, 0xC0	; 192
    13a0:	a9 d6       	rcall	.+3410   	; 0x20f4 <__data_load_end+0x448>
				lcd_eep_string(K);	//"K="
    13a2:	8c eb       	ldi	r24, 0xBC	; 188
    13a4:	90 e0       	ldi	r25, 0x00	; 0
    13a6:	09 d7       	rcall	.+3602   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(diodes[0].Cathode + 49);
    13a8:	80 91 a4 00 	lds	r24, 0x00A4
    13ac:	8f 5c       	subi	r24, 0xCF	; 207
    13ae:	83 d6       	rcall	.+3334   	; 0x20b6 <__data_load_end+0x40a>
				lcd_eep_string(A1);		//";A1="
    13b0:	88 e0       	ldi	r24, 0x08	; 8
    13b2:	91 e0       	ldi	r25, 0x01	; 1
    13b4:	02 d7       	rcall	.+3588   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(diodes[0].Anode + 49);
    13b6:	80 91 a3 00 	lds	r24, 0x00A3
    13ba:	8f 5c       	subi	r24, 0xCF	; 207
    13bc:	7c d6       	rcall	.+3320   	; 0x20b6 <__data_load_end+0x40a>
				lcd_eep_string(A2);		//";A2="
    13be:	8d e0       	ldi	r24, 0x0D	; 13
    13c0:	91 e0       	ldi	r25, 0x01	; 1
    13c2:	fb d6       	rcall	.+3574   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(diodes[1].Anode + 49);
    13c4:	80 91 a7 00 	lds	r24, 0x00A7
    13c8:	00 c2       	rjmp	.+1024   	; 0x17ca <main+0x708>
				goto end;
			} else if ((diodes[0].Cathode == diodes[1].Anode) && (diodes[1].Cathode == diodes[0].Anode)) {
    13ca:	32 17       	cp	r19, r18
    13cc:	09 f0       	breq	.+2      	; 0x13d0 <main+0x30e>
    13ce:	24 c3       	rjmp	.+1608   	; 0x1a18 <main+0x956>
    13d0:	98 17       	cp	r25, r24
    13d2:	09 f0       	breq	.+2      	; 0x13d6 <main+0x314>
    13d4:	21 c3       	rjmp	.+1602   	; 0x1a18 <main+0x956>
				//Antiparallel
				lcd_eep_string(TwoDiodes);	//2 Dioden
    13d6:	87 e8       	ldi	r24, 0x87	; 135
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	ef d6       	rcall	.+3550   	; 0x21ba <__data_load_end+0x50e>
				Line2(); //2. Zeile
    13dc:	80 ec       	ldi	r24, 0xC0	; 192
    13de:	8a d6       	rcall	.+3348   	; 0x20f4 <__data_load_end+0x448>
				lcd_eep_string(Antiparallel);	//Antiparallel
    13e0:	8f e8       	ldi	r24, 0x8F	; 143
    13e2:	90 e0       	ldi	r25, 0x00	; 0
    13e4:	27 c3       	rjmp	.+1614   	; 0x1a34 <main+0x972>
				goto end;
			}
		} else if(NumOfDiodes == 3) {
    13e6:	83 30       	cpi	r24, 0x03	; 3
    13e8:	09 f0       	breq	.+2      	; 0x13ec <main+0x32a>
    13ea:	16 c3       	rjmp	.+1580   	; 0x1a18 <main+0x956>
			//Serienschaltung aus 2 Dioden; wird als 3 Dioden erkannt
			b = 3;
    13ec:	80 93 64 00 	sts	0x0064, r24
			c = 3;
    13f0:	80 93 83 00 	sts	0x0083, r24
			/* Überprüfen auf eine für eine Serienschaltung von 2 Dioden mögliche Konstellation
				Dafür müssen 2 der Kathoden und 2 der Anoden übereinstimmen.
				Das kommmt daher, dass die Dioden als 2 Einzeldioden und ZUSÄTZLICH als eine "große" Diode erkannt werden.
			*/
			if((diodes[0].Anode == diodes[1].Anode) || (diodes[0].Anode == diodes[2].Anode)) b = diodes[0].Anode;
    13f4:	90 91 a3 00 	lds	r25, 0x00A3
    13f8:	80 91 a7 00 	lds	r24, 0x00A7
    13fc:	98 17       	cp	r25, r24
    13fe:	21 f0       	breq	.+8      	; 0x1408 <main+0x346>
    1400:	20 91 ab 00 	lds	r18, 0x00AB
    1404:	92 17       	cp	r25, r18
    1406:	11 f4       	brne	.+4      	; 0x140c <main+0x34a>
    1408:	90 93 64 00 	sts	0x0064, r25
			if(diodes[1].Anode == diodes[2].Anode) b = diodes[1].Anode;
    140c:	90 91 ab 00 	lds	r25, 0x00AB
    1410:	89 17       	cp	r24, r25
    1412:	11 f4       	brne	.+4      	; 0x1418 <main+0x356>
    1414:	80 93 64 00 	sts	0x0064, r24

			if((diodes[0].Cathode == diodes[1].Cathode) || (diodes[0].Cathode == diodes[2].Cathode)) c = diodes[0].Cathode;
    1418:	90 91 a4 00 	lds	r25, 0x00A4
    141c:	80 91 a8 00 	lds	r24, 0x00A8
    1420:	98 17       	cp	r25, r24
    1422:	21 f0       	breq	.+8      	; 0x142c <main+0x36a>
    1424:	20 91 ac 00 	lds	r18, 0x00AC
    1428:	92 17       	cp	r25, r18
    142a:	11 f4       	brne	.+4      	; 0x1430 <main+0x36e>
    142c:	90 93 83 00 	sts	0x0083, r25
			if(diodes[1].Cathode == diodes[2].Cathode) c = diodes[1].Cathode;
    1430:	90 91 ac 00 	lds	r25, 0x00AC
    1434:	89 17       	cp	r24, r25
    1436:	11 f4       	brne	.+4      	; 0x143c <main+0x37a>
    1438:	80 93 83 00 	sts	0x0083, r24
			if((b<3) && (c<3)) {
    143c:	80 91 64 00 	lds	r24, 0x0064
    1440:	83 30       	cpi	r24, 0x03	; 3
    1442:	08 f0       	brcs	.+2      	; 0x1446 <main+0x384>
    1444:	e9 c2       	rjmp	.+1490   	; 0x1a18 <main+0x956>
    1446:	80 91 83 00 	lds	r24, 0x0083
    144a:	83 30       	cpi	r24, 0x03	; 3
    144c:	08 f0       	brcs	.+2      	; 0x1450 <main+0x38e>
    144e:	e4 c2       	rjmp	.+1480   	; 0x1a18 <main+0x956>
				lcd_eep_string(TwoDiodes);//2 Dioden
    1450:	87 e8       	ldi	r24, 0x87	; 135
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	b2 d6       	rcall	.+3428   	; 0x21ba <__data_load_end+0x50e>
				Line2(); //2. Zeile
    1456:	80 ec       	ldi	r24, 0xC0	; 192
    1458:	4d d6       	rcall	.+3226   	; 0x20f4 <__data_load_end+0x448>
				lcd_eep_string(InSeries); //"in Serie A="
    145a:	80 ea       	ldi	r24, 0xA0	; 160
    145c:	90 e0       	ldi	r25, 0x00	; 0
    145e:	ad d6       	rcall	.+3418   	; 0x21ba <__data_load_end+0x50e>
				lcd_data(b + 49);
    1460:	80 91 64 00 	lds	r24, 0x0064
    1464:	8f 5c       	subi	r24, 0xCF	; 207
    1466:	27 d6       	rcall	.+3150   	; 0x20b6 <__data_load_end+0x40a>
				lcd_eep_string(NextK);
    1468:	88 eb       	ldi	r24, 0xB8	; 184
    146a:	90 e0       	ldi	r25, 0x00	; 0
    146c:	ab c1       	rjmp	.+854    	; 0x17c4 <main+0x702>
				lcd_data(c + 49);
				goto end;
			}
		}
	} else if (PartFound == PART_TRANSISTOR) {
    146e:	82 30       	cpi	r24, 0x02	; 2
    1470:	09 f0       	breq	.+2      	; 0x1474 <main+0x3b2>
    1472:	e0 c0       	rjmp	.+448    	; 0x1634 <main+0x572>
		if(PartReady == 0) {	//Wenn 2. Prüfung nie gemacht, z.B. bei Transistor mit Schutzdiode
    1474:	80 91 65 00 	lds	r24, 0x0065
    1478:	88 23       	and	r24, r24
    147a:	81 f4       	brne	.+32     	; 0x149c <main+0x3da>
			hfe[1] = hfe[0];
    147c:	80 91 9c 00 	lds	r24, 0x009C
    1480:	90 91 9d 00 	lds	r25, 0x009D
    1484:	90 93 9f 00 	sts	0x009F, r25
    1488:	80 93 9e 00 	sts	0x009E, r24
			uBE[1] = uBE[0];
    148c:	80 91 8c 00 	lds	r24, 0x008C
    1490:	90 91 8d 00 	lds	r25, 0x008D
    1494:	90 93 8f 00 	sts	0x008F, r25
    1498:	80 93 8e 00 	sts	0x008E, r24
		}
		if((hfe[0]>hfe[1])) {	//Wenn der Verstärkungsfaktor beim ersten Test höher war: C und E vertauschen!
    149c:	80 91 9c 00 	lds	r24, 0x009C
    14a0:	90 91 9d 00 	lds	r25, 0x009D
    14a4:	20 91 9e 00 	lds	r18, 0x009E
    14a8:	30 91 9f 00 	lds	r19, 0x009F
    14ac:	28 17       	cp	r18, r24
    14ae:	39 07       	cpc	r19, r25
    14b0:	a0 f4       	brcc	.+40     	; 0x14da <main+0x418>
			hfe[1] = hfe[0];
    14b2:	90 93 9f 00 	sts	0x009F, r25
    14b6:	80 93 9e 00 	sts	0x009E, r24
			uBE[1] = uBE[0];
    14ba:	80 91 8c 00 	lds	r24, 0x008C
    14be:	90 91 8d 00 	lds	r25, 0x008D
    14c2:	90 93 8f 00 	sts	0x008F, r25
    14c6:	80 93 8e 00 	sts	0x008E, r24
			tmp = c;
    14ca:	80 91 83 00 	lds	r24, 0x0083
			c = e;
    14ce:	90 91 a2 00 	lds	r25, 0x00A2
    14d2:	90 93 83 00 	sts	0x0083, r25
			e = tmp;
    14d6:	80 93 a2 00 	sts	0x00A2, r24
		}

		if(PartMode == PART_MODE_NPN) {
    14da:	80 91 67 00 	lds	r24, 0x0067
    14de:	81 30       	cpi	r24, 0x01	; 1
    14e0:	19 f4       	brne	.+6      	; 0x14e8 <main+0x426>
			lcd_eep_string(NPN);
    14e2:	8e e1       	ldi	r24, 0x1E	; 30
    14e4:	91 e0       	ldi	r25, 0x01	; 1
    14e6:	02 c0       	rjmp	.+4      	; 0x14ec <main+0x42a>
		} else {
			lcd_eep_string(PNP);
    14e8:	82 e2       	ldi	r24, 0x22	; 34
    14ea:	91 e0       	ldi	r25, 0x01	; 1
    14ec:	66 d6       	rcall	.+3276   	; 0x21ba <__data_load_end+0x50e>
		}
		lcd_eep_string(bstr);	//B=
    14ee:	86 e2       	ldi	r24, 0x26	; 38
    14f0:	91 e0       	ldi	r25, 0x01	; 1
    14f2:	63 d6       	rcall	.+3270   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(b + 49);
    14f4:	80 91 64 00 	lds	r24, 0x0064
    14f8:	8f 5c       	subi	r24, 0xCF	; 207
    14fa:	dd d5       	rcall	.+3002   	; 0x20b6 <__data_load_end+0x40a>
		lcd_eep_string(cstr);	//;C=
    14fc:	8a e2       	ldi	r24, 0x2A	; 42
    14fe:	91 e0       	ldi	r25, 0x01	; 1
    1500:	5c d6       	rcall	.+3256   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(c + 49);
    1502:	80 91 83 00 	lds	r24, 0x0083
    1506:	8f 5c       	subi	r24, 0xCF	; 207
    1508:	d6 d5       	rcall	.+2988   	; 0x20b6 <__data_load_end+0x40a>
		lcd_eep_string(estr);	//;E=
    150a:	8e e2       	ldi	r24, 0x2E	; 46
    150c:	91 e0       	ldi	r25, 0x01	; 1
    150e:	55 d6       	rcall	.+3242   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(e + 49);
    1510:	80 91 a2 00 	lds	r24, 0x00A2
    1514:	8f 5c       	subi	r24, 0xCF	; 207
    1516:	cf d5       	rcall	.+2974   	; 0x20b6 <__data_load_end+0x40a>
		Line2(); //2. Zeile
    1518:	80 ec       	ldi	r24, 0xC0	; 192
    151a:	ec d5       	rcall	.+3032   	; 0x20f4 <__data_load_end+0x448>
		//Verstärkungsfaktor berechnen
		//hFE = Emitterstrom / Basisstrom
		lhfe = hfe[1];

		#ifdef UseM8
			lhfe *= (((unsigned long)rhval * 100) / (unsigned long)rlval);	//Verhältnis von High- zu Low-Widerstand
    151c:	c4 01       	movw	r24, r8
    151e:	b3 01       	movw	r22, r6
    1520:	a2 01       	movw	r20, r4
    1522:	91 01       	movw	r18, r2
    1524:	1a d3       	rcall	.+1588   	; 0x1b5a <__udivmodsi4>
    1526:	79 01       	movw	r14, r18
    1528:	8a 01       	movw	r16, r20
		lcd_eep_string(estr);	//;E=
		lcd_data(e + 49);
		Line2(); //2. Zeile
		//Verstärkungsfaktor berechnen
		//hFE = Emitterstrom / Basisstrom
		lhfe = hfe[1];
    152a:	20 91 9e 00 	lds	r18, 0x009E
    152e:	30 91 9f 00 	lds	r19, 0x009F
    1532:	40 e0       	ldi	r20, 0x00	; 0
    1534:	50 e0       	ldi	r21, 0x00	; 0

		#ifdef UseM8
			lhfe *= (((unsigned long)rhval * 100) / (unsigned long)rlval);	//Verhältnis von High- zu Low-Widerstand
    1536:	c8 01       	movw	r24, r16
    1538:	b7 01       	movw	r22, r14
    153a:	dc d2       	rcall	.+1464   	; 0x1af4 <__mulsi3>
		#else
			lhfe *= M48_RH_RL_RATIO;
		#endif
		if(uBE[1]<11) uBE[1] = 11;
    153c:	20 91 8e 00 	lds	r18, 0x008E
    1540:	30 91 8f 00 	lds	r19, 0x008F
    1544:	2b 30       	cpi	r18, 0x0B	; 11
    1546:	31 05       	cpc	r19, r1
    1548:	30 f4       	brcc	.+12     	; 0x1556 <main+0x494>
    154a:	2b e0       	ldi	r18, 0x0B	; 11
    154c:	30 e0       	ldi	r19, 0x00	; 0
    154e:	30 93 8f 00 	sts	0x008F, r19
    1552:	20 93 8e 00 	sts	0x008E, r18
		lhfe /= uBE[1];
    1556:	20 91 8e 00 	lds	r18, 0x008E
    155a:	30 91 8f 00 	lds	r19, 0x008F
    155e:	40 e0       	ldi	r20, 0x00	; 0
    1560:	50 e0       	ldi	r21, 0x00	; 0
    1562:	fb d2       	rcall	.+1526   	; 0x1b5a <__udivmodsi4>
    1564:	20 93 90 00 	sts	0x0090, r18
    1568:	30 93 91 00 	sts	0x0091, r19
    156c:	40 93 92 00 	sts	0x0092, r20
    1570:	50 93 93 00 	sts	0x0093, r21
		hfe[1] = (unsigned int) lhfe;
    1574:	20 93 9e 00 	sts	0x009E, r18
    1578:	30 93 9f 00 	sts	0x009F, r19
		lcd_eep_string(hfestr);	//"hFE="
    157c:	89 e1       	ldi	r24, 0x19	; 25
    157e:	91 e0       	ldi	r25, 0x01	; 1
    1580:	1c d6       	rcall	.+3128   	; 0x21ba <__data_load_end+0x50e>
		lcd_string(utoa(hfe[1], outval, 10));
    1582:	80 91 9e 00 	lds	r24, 0x009E
    1586:	90 91 9f 00 	lds	r25, 0x009F
    158a:	60 e7       	ldi	r22, 0x70	; 112
    158c:	70 e0       	ldi	r23, 0x00	; 0
    158e:	4a e0       	ldi	r20, 0x0A	; 10
    1590:	50 e0       	ldi	r21, 0x00	; 0
    1592:	47 d3       	rcall	.+1678   	; 0x1c22 <utoa>
    1594:	ff d5       	rcall	.+3070   	; 0x2194 <__data_load_end+0x4e8>
		SetCursor(2,7);			//Cursor auf Zeile 2, Zeichen 7
    1596:	87 ec       	ldi	r24, 0xC7	; 199
    1598:	ad d5       	rcall	.+2906   	; 0x20f4 <__data_load_end+0x448>
		if(NumOfDiodes > 2) {	//Transistor mit Schutzdiode
    159a:	80 91 66 00 	lds	r24, 0x0066
    159e:	83 30       	cpi	r24, 0x03	; 3
    15a0:	10 f0       	brcs	.+4      	; 0x15a6 <main+0x4e4>
			lcd_data(LCD_CHAR_DIODE);	//Diode anzeigen
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	01 c0       	rjmp	.+2      	; 0x15a8 <main+0x4e6>
		} else {
			#ifdef UseM8
				lcd_data(' ');
    15a6:	80 e2       	ldi	r24, 0x20	; 32
    15a8:	86 d5       	rcall	.+2828   	; 0x20b6 <__data_load_end+0x40a>
			#endif
		}
		#ifdef UseM8
			for(c=0;c<NumOfDiodes;c++) {
    15aa:	70 91 66 00 	lds	r23, 0x0066
				if(((diodes[c].Cathode == e) && (diodes[c].Anode == b) && (PartMode == PART_MODE_NPN)) || ((diodes[c].Anode == e) && (diodes[c].Cathode == b) && (PartMode == PART_MODE_PNP))) {
    15ae:	50 91 a2 00 	lds	r21, 0x00A2
    15b2:	40 91 64 00 	lds	r20, 0x0064
    15b6:	30 91 67 00 	lds	r19, 0x0067
			#ifdef UseM8
				lcd_data(' ');
			#endif
		}
		#ifdef UseM8
			for(c=0;c<NumOfDiodes;c++) {
    15ba:	20 e0       	ldi	r18, 0x00	; 0
    15bc:	36 c0       	rjmp	.+108    	; 0x162a <main+0x568>
				if(((diodes[c].Cathode == e) && (diodes[c].Anode == b) && (PartMode == PART_MODE_NPN)) || ((diodes[c].Anode == e) && (diodes[c].Cathode == b) && (PartMode == PART_MODE_PNP))) {
    15be:	82 2f       	mov	r24, r18
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	fc 01       	movw	r30, r24
    15c4:	ee 0f       	add	r30, r30
    15c6:	ff 1f       	adc	r31, r31
    15c8:	ee 0f       	add	r30, r30
    15ca:	ff 1f       	adc	r31, r31
    15cc:	ed 55       	subi	r30, 0x5D	; 93
    15ce:	ff 4f       	sbci	r31, 0xFF	; 255
    15d0:	61 81       	ldd	r22, Z+1	; 0x01
    15d2:	65 17       	cp	r22, r21
    15d4:	29 f4       	brne	.+10     	; 0x15e0 <main+0x51e>
    15d6:	e0 81       	ld	r30, Z
    15d8:	e4 17       	cp	r30, r20
    15da:	11 f4       	brne	.+4      	; 0x15e0 <main+0x51e>
    15dc:	31 30       	cpi	r19, 0x01	; 1
    15de:	71 f0       	breq	.+28     	; 0x15fc <main+0x53a>
    15e0:	fc 01       	movw	r30, r24
    15e2:	ee 0f       	add	r30, r30
    15e4:	ff 1f       	adc	r31, r31
    15e6:	ee 0f       	add	r30, r30
    15e8:	ff 1f       	adc	r31, r31
    15ea:	ed 55       	subi	r30, 0x5D	; 93
    15ec:	ff 4f       	sbci	r31, 0xFF	; 255
    15ee:	80 81       	ld	r24, Z
    15f0:	85 17       	cp	r24, r21
    15f2:	d1 f4       	brne	.+52     	; 0x1628 <main+0x566>
    15f4:	64 17       	cp	r22, r20
    15f6:	c1 f4       	brne	.+48     	; 0x1628 <main+0x566>
    15f8:	32 30       	cpi	r19, 0x02	; 2
    15fa:	b1 f4       	brne	.+44     	; 0x1628 <main+0x566>
    15fc:	20 93 83 00 	sts	0x0083, r18
					lcd_eep_string(Uf);	//"Uf="
    1600:	87 e3       	ldi	r24, 0x37	; 55
    1602:	91 e0       	ldi	r25, 0x01	; 1
    1604:	da d5       	rcall	.+2996   	; 0x21ba <__data_load_end+0x50e>
					lcd_string(itoa(diodes[c].Voltage, outval, 10));
    1606:	e0 91 83 00 	lds	r30, 0x0083
    160a:	f0 e0       	ldi	r31, 0x00	; 0
    160c:	ee 0f       	add	r30, r30
    160e:	ff 1f       	adc	r31, r31
    1610:	ee 0f       	add	r30, r30
    1612:	ff 1f       	adc	r31, r31
    1614:	ed 55       	subi	r30, 0x5D	; 93
    1616:	ff 4f       	sbci	r31, 0xFF	; 255
    1618:	82 81       	ldd	r24, Z+2	; 0x02
    161a:	93 81       	ldd	r25, Z+3	; 0x03
    161c:	60 e7       	ldi	r22, 0x70	; 112
    161e:	70 e0       	ldi	r23, 0x00	; 0
    1620:	4a e0       	ldi	r20, 0x0A	; 10
    1622:	50 e0       	ldi	r21, 0x00	; 0
    1624:	bc d2       	rcall	.+1400   	; 0x1b9e <itoa>
    1626:	9f c0       	rjmp	.+318    	; 0x1766 <main+0x6a4>
					lcd_data('m');
					goto end;
    1628:	2f 5f       	subi	r18, 0xFF	; 255
			#ifdef UseM8
				lcd_data(' ');
			#endif
		}
		#ifdef UseM8
			for(c=0;c<NumOfDiodes;c++) {
    162a:	27 17       	cp	r18, r23
    162c:	40 f2       	brcs	.-112    	; 0x15be <main+0x4fc>
    162e:	20 93 83 00 	sts	0x0083, r18
    1632:	13 c2       	rjmp	.+1062   	; 0x1a5a <main+0x998>
					goto end;
				}
			}
		#endif
		goto end;
	} else if (PartFound == PART_FET) {	//JFET oder MOSFET
    1634:	83 30       	cpi	r24, 0x03	; 3
    1636:	09 f0       	breq	.+2      	; 0x163a <main+0x578>
    1638:	99 c0       	rjmp	.+306    	; 0x176c <main+0x6aa>
		if(PartMode&1) {	//N-Kanal
    163a:	80 91 67 00 	lds	r24, 0x0067
    163e:	80 ff       	sbrs	r24, 0
    1640:	02 c0       	rjmp	.+4      	; 0x1646 <main+0x584>
			lcd_data('N');
    1642:	8e e4       	ldi	r24, 0x4E	; 78
    1644:	01 c0       	rjmp	.+2      	; 0x1648 <main+0x586>
		} else {
			lcd_data('P');	//P-Kanal
    1646:	80 e5       	ldi	r24, 0x50	; 80
    1648:	36 d5       	rcall	.+2668   	; 0x20b6 <__data_load_end+0x40a>
		}
		if((PartMode==PART_MODE_N_D_MOS) || (PartMode==PART_MODE_P_D_MOS)) {
    164a:	80 91 67 00 	lds	r24, 0x0067
    164e:	98 2f       	mov	r25, r24
    1650:	93 50       	subi	r25, 0x03	; 3
    1652:	92 30       	cpi	r25, 0x02	; 2
    1654:	18 f4       	brcc	.+6      	; 0x165c <main+0x59a>
			lcd_eep_string(dmode);	//"-D"
    1656:	8f ef       	ldi	r24, 0xFF	; 255
    1658:	90 e0       	ldi	r25, 0x00	; 0
    165a:	08 c0       	rjmp	.+16     	; 0x166c <main+0x5aa>
			lcd_eep_string(mosfet);	//"-MOS"
		} else {
			if((PartMode==PART_MODE_N_JFET) || (PartMode==PART_MODE_P_JFET)) {
    165c:	85 50       	subi	r24, 0x05	; 5
    165e:	82 30       	cpi	r24, 0x02	; 2
    1660:	18 f4       	brcc	.+6      	; 0x1668 <main+0x5a6>
				lcd_eep_string(jfet);	//"-JFET"
    1662:	82 e0       	ldi	r24, 0x02	; 2
    1664:	91 e0       	ldi	r25, 0x01	; 1
    1666:	05 c0       	rjmp	.+10     	; 0x1672 <main+0x5b0>
			} else {
				lcd_eep_string(emode);	//"-E"
    1668:	8c ef       	ldi	r24, 0xFC	; 252
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	a6 d5       	rcall	.+2892   	; 0x21ba <__data_load_end+0x50e>
				lcd_eep_string(mosfet);	//"-MOS"
    166e:	87 ef       	ldi	r24, 0xF7	; 247
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	a3 d5       	rcall	.+2886   	; 0x21ba <__data_load_end+0x50e>
			}
		}
		#ifdef UseM8	//Gatekapazität
			if(PartMode < 3) {	//Anreicherungs-MOSFET
    1674:	80 91 67 00 	lds	r24, 0x0067
    1678:	83 30       	cpi	r24, 0x03	; 3
    167a:	d0 f5       	brcc	.+116    	; 0x16f0 <main+0x62e>
				lcd_eep_string(GateCap);	//" C="
    167c:	85 e1       	ldi	r24, 0x15	; 21
    167e:	91 e0       	ldi	r25, 0x01	; 1
    1680:	9c d5       	rcall	.+2872   	; 0x21ba <__data_load_end+0x50e>
				ReadCapacity(b,e);	//Messung
    1682:	80 91 64 00 	lds	r24, 0x0064
    1686:	60 91 a2 00 	lds	r22, 0x00A2
    168a:	e1 d5       	rcall	.+3010   	; 0x224e <__data_load_end+0x5a2>
				hfe[0] = (unsigned int)cv;
    168c:	80 91 6b 00 	lds	r24, 0x006B
    1690:	90 91 6c 00 	lds	r25, 0x006C
    1694:	90 93 9d 00 	sts	0x009D, r25
    1698:	80 93 9c 00 	sts	0x009C, r24
				if(hfe[0]>2) hfe[0] -= 3;
    169c:	83 30       	cpi	r24, 0x03	; 3
    169e:	91 05       	cpc	r25, r1
    16a0:	28 f0       	brcs	.+10     	; 0x16ac <main+0x5ea>
    16a2:	03 97       	sbiw	r24, 0x03	; 3
    16a4:	90 93 9d 00 	sts	0x009D, r25
    16a8:	80 93 9c 00 	sts	0x009C, r24
				utoa(hfe[0], outval2, 10);
    16ac:	80 91 9c 00 	lds	r24, 0x009C
    16b0:	90 91 9d 00 	lds	r25, 0x009D
    16b4:	69 e7       	ldi	r22, 0x79	; 121
    16b6:	70 e0       	ldi	r23, 0x00	; 0
    16b8:	4a e0       	ldi	r20, 0x0A	; 10
    16ba:	50 e0       	ldi	r21, 0x00	; 0
    16bc:	b2 d2       	rcall	.+1380   	; 0x1c22 <utoa>

				tmpval = strlen(outval2);
    16be:	e9 e7       	ldi	r30, 0x79	; 121
    16c0:	f0 e0       	ldi	r31, 0x00	; 0
    16c2:	01 90       	ld	r0, Z+
    16c4:	00 20       	and	r0, r0
    16c6:	e9 f7       	brne	.-6      	; 0x16c2 <main+0x600>
    16c8:	31 97       	sbiw	r30, 0x01	; 1
    16ca:	e9 57       	subi	r30, 0x79	; 121
    16cc:	f0 40       	sbci	r31, 0x00	; 0
    16ce:	4e 2f       	mov	r20, r30
    16d0:	e0 93 6a 00 	sts	0x006A, r30
				tmpval2 = tmpval;
    16d4:	e0 93 78 00 	sts	0x0078, r30
				if(tmpval>4) tmpval = 4;	//bei Kapazität >100nF letze Nachkommastelle nicht mehr angeben (passt sonst nicht auf das LCD)
    16d8:	e5 30       	cpi	r30, 0x05	; 5
    16da:	18 f0       	brcs	.+6      	; 0x16e2 <main+0x620>
    16dc:	84 e0       	ldi	r24, 0x04	; 4
    16de:	80 93 6a 00 	sts	0x006A, r24
				lcd_show_format_cap(outval2, tmpval, tmpval2);
    16e2:	89 e7       	ldi	r24, 0x79	; 121
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	60 91 6a 00 	lds	r22, 0x006A
    16ea:	a3 dc       	rcall	.-1722   	; 0x1032 <lcd_show_format_cap>
				lcd_data('n');
    16ec:	8e e6       	ldi	r24, 0x6E	; 110
    16ee:	e3 d4       	rcall	.+2502   	; 0x20b6 <__data_load_end+0x40a>
			}
		#endif
		Line2(); //2. Zeile
    16f0:	80 ec       	ldi	r24, 0xC0	; 192
    16f2:	00 d5       	rcall	.+2560   	; 0x20f4 <__data_load_end+0x448>
		lcd_eep_string(gds);	//"GDS="
    16f4:	82 e3       	ldi	r24, 0x32	; 50
    16f6:	91 e0       	ldi	r25, 0x01	; 1
    16f8:	60 d5       	rcall	.+2752   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(b + 49);
    16fa:	80 91 64 00 	lds	r24, 0x0064
    16fe:	8f 5c       	subi	r24, 0xCF	; 207
    1700:	da d4       	rcall	.+2484   	; 0x20b6 <__data_load_end+0x40a>
		lcd_data(c + 49);
    1702:	80 91 83 00 	lds	r24, 0x0083
    1706:	8f 5c       	subi	r24, 0xCF	; 207
    1708:	d6 d4       	rcall	.+2476   	; 0x20b6 <__data_load_end+0x40a>
		lcd_data(e + 49);
    170a:	80 91 a2 00 	lds	r24, 0x00A2
    170e:	8f 5c       	subi	r24, 0xCF	; 207
    1710:	d2 d4       	rcall	.+2468   	; 0x20b6 <__data_load_end+0x40a>
		if((NumOfDiodes > 0) && (PartMode < 3)) {	//MOSFET mit Schutzdiode; gibt es nur bei Anreicherungs-FETs
    1712:	80 91 66 00 	lds	r24, 0x0066
    1716:	88 23       	and	r24, r24
    1718:	31 f0       	breq	.+12     	; 0x1726 <main+0x664>
    171a:	80 91 67 00 	lds	r24, 0x0067
    171e:	83 30       	cpi	r24, 0x03	; 3
    1720:	10 f4       	brcc	.+4      	; 0x1726 <main+0x664>
			lcd_data(LCD_CHAR_DIODE);	//Diode anzeigen
    1722:	80 e0       	ldi	r24, 0x00	; 0
    1724:	01 c0       	rjmp	.+2      	; 0x1728 <main+0x666>
		} else {
			lcd_data(' ');	//Leerzeichen
    1726:	80 e2       	ldi	r24, 0x20	; 32
    1728:	c6 d4       	rcall	.+2444   	; 0x20b6 <__data_load_end+0x40a>
		}
		if(PartMode < 3) {	//Anreicherungs-MOSFET
    172a:	80 91 67 00 	lds	r24, 0x0067
    172e:	83 30       	cpi	r24, 0x03	; 3
    1730:	08 f0       	brcs	.+2      	; 0x1734 <main+0x672>
    1732:	93 c1       	rjmp	.+806    	; 0x1a5a <main+0x998>
			gthvoltage=(gthvoltage/8);
    1734:	80 91 99 00 	lds	r24, 0x0099
    1738:	90 91 9a 00 	lds	r25, 0x009A
    173c:	33 e0       	ldi	r19, 0x03	; 3
    173e:	96 95       	lsr	r25
    1740:	87 95       	ror	r24
    1742:	3a 95       	dec	r19
    1744:	e1 f7       	brne	.-8      	; 0x173e <main+0x67c>
    1746:	90 93 9a 00 	sts	0x009A, r25
    174a:	80 93 99 00 	sts	0x0099, r24
			lcd_eep_string(vt);
    174e:	8b e3       	ldi	r24, 0x3B	; 59
    1750:	91 e0       	ldi	r25, 0x01	; 1
    1752:	33 d5       	rcall	.+2662   	; 0x21ba <__data_load_end+0x50e>
			lcd_string(utoa(gthvoltage, outval, 10));	//Gate-Schwellspannung, wurde zuvor ermittelt
    1754:	80 91 99 00 	lds	r24, 0x0099
    1758:	90 91 9a 00 	lds	r25, 0x009A
    175c:	60 e7       	ldi	r22, 0x70	; 112
    175e:	70 e0       	ldi	r23, 0x00	; 0
    1760:	4a e0       	ldi	r20, 0x0A	; 10
    1762:	50 e0       	ldi	r21, 0x00	; 0
    1764:	5e d2       	rcall	.+1212   	; 0x1c22 <utoa>
    1766:	16 d5       	rcall	.+2604   	; 0x2194 <__data_load_end+0x4e8>
			lcd_data('m');
    1768:	8d e6       	ldi	r24, 0x6D	; 109
    176a:	76 c1       	rjmp	.+748    	; 0x1a58 <main+0x996>
		}
		goto end;
	} else if (PartFound == PART_THYRISTOR) {
    176c:	85 30       	cpi	r24, 0x05	; 5
    176e:	99 f4       	brne	.+38     	; 0x1796 <main+0x6d4>
		lcd_eep_string(Thyristor);	//"Thyristor"
    1770:	88 ec       	ldi	r24, 0xC8	; 200
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	22 d5       	rcall	.+2628   	; 0x21ba <__data_load_end+0x50e>
		Line2(); //2. Zeile
    1776:	80 ec       	ldi	r24, 0xC0	; 192
    1778:	bd d4       	rcall	.+2426   	; 0x20f4 <__data_load_end+0x448>
		lcd_eep_string(GAK);	//"GAK="
    177a:	83 eb       	ldi	r24, 0xB3	; 179
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	1d d5       	rcall	.+2618   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(b + 49);
    1780:	80 91 64 00 	lds	r24, 0x0064
    1784:	8f 5c       	subi	r24, 0xCF	; 207
    1786:	97 d4       	rcall	.+2350   	; 0x20b6 <__data_load_end+0x40a>
		lcd_data(c + 49);
    1788:	80 91 83 00 	lds	r24, 0x0083
    178c:	8f 5c       	subi	r24, 0xCF	; 207
    178e:	93 d4       	rcall	.+2342   	; 0x20b6 <__data_load_end+0x40a>
		lcd_data(e + 49);
    1790:	80 91 a2 00 	lds	r24, 0x00A2
    1794:	1a c0       	rjmp	.+52     	; 0x17ca <main+0x708>
		goto end;
	} else if (PartFound == PART_TRIAC) {
    1796:	84 30       	cpi	r24, 0x04	; 4
    1798:	d1 f4       	brne	.+52     	; 0x17ce <main+0x70c>
		lcd_eep_string(Triac);	//"Triac"
    179a:	8f eb       	ldi	r24, 0xBF	; 191
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	0d d5       	rcall	.+2586   	; 0x21ba <__data_load_end+0x50e>
		Line2(); //2. Zeile
    17a0:	80 ec       	ldi	r24, 0xC0	; 192
    17a2:	a8 d4       	rcall	.+2384   	; 0x20f4 <__data_load_end+0x448>
		lcd_eep_string(Gate);
    17a4:	85 e4       	ldi	r24, 0x45	; 69
    17a6:	91 e0       	ldi	r25, 0x01	; 1
    17a8:	08 d5       	rcall	.+2576   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(b + 49);
    17aa:	80 91 64 00 	lds	r24, 0x0064
    17ae:	8f 5c       	subi	r24, 0xCF	; 207
    17b0:	82 d4       	rcall	.+2308   	; 0x20b6 <__data_load_end+0x40a>
		lcd_eep_string(A1);		//";A1="
    17b2:	88 e0       	ldi	r24, 0x08	; 8
    17b4:	91 e0       	ldi	r25, 0x01	; 1
    17b6:	01 d5       	rcall	.+2562   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(e + 49);
    17b8:	80 91 a2 00 	lds	r24, 0x00A2
    17bc:	8f 5c       	subi	r24, 0xCF	; 207
    17be:	7b d4       	rcall	.+2294   	; 0x20b6 <__data_load_end+0x40a>
		lcd_eep_string(A2);		//";A2="
    17c0:	8d e0       	ldi	r24, 0x0D	; 13
    17c2:	91 e0       	ldi	r25, 0x01	; 1
    17c4:	fa d4       	rcall	.+2548   	; 0x21ba <__data_load_end+0x50e>
		lcd_data(c + 49);
    17c6:	80 91 83 00 	lds	r24, 0x0083
    17ca:	8f 5c       	subi	r24, 0xCF	; 207
    17cc:	45 c1       	rjmp	.+650    	; 0x1a58 <main+0x996>
		goto end;
	#ifdef UseM8	//Widerstandsmessung nur mit Mega8 verfügbar
		} else if(PartFound == PART_RESISTOR) {
    17ce:	86 30       	cpi	r24, 0x06	; 6
    17d0:	09 f0       	breq	.+2      	; 0x17d4 <main+0x712>
    17d2:	cc c0       	rjmp	.+408    	; 0x196c <main+0x8aa>
			lcd_eep_string(Resistor); //"Widerstand: "
    17d4:	8e ed       	ldi	r24, 0xDE	; 222
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	f0 d4       	rcall	.+2528   	; 0x21ba <__data_load_end+0x50e>
			lcd_data(ra + 49);	//Pin-Angaben
    17da:	80 91 bc 00 	lds	r24, 0x00BC
    17de:	8f 5c       	subi	r24, 0xCF	; 207
    17e0:	6a d4       	rcall	.+2260   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data('-');
    17e2:	8d e2       	ldi	r24, 0x2D	; 45
    17e4:	68 d4       	rcall	.+2256   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data(rb + 49);
    17e6:	80 91 6f 00 	lds	r24, 0x006F
    17ea:	8f 5c       	subi	r24, 0xCF	; 207
    17ec:	64 d4       	rcall	.+2248   	; 0x20b6 <__data_load_end+0x40a>
			Line2(); //2. Zeile
    17ee:	80 ec       	ldi	r24, 0xC0	; 192
    17f0:	81 d4       	rcall	.+2306   	; 0x20f4 <__data_load_end+0x448>
			if(rv[0]>512) {		//Überprüfen, wie weit die an den Testwiderständen anliegenden Spannungen von 512 abweichen
    17f2:	20 91 94 00 	lds	r18, 0x0094
    17f6:	30 91 95 00 	lds	r19, 0x0095
    17fa:	b2 e0       	ldi	r27, 0x02	; 2
    17fc:	21 30       	cpi	r18, 0x01	; 1
    17fe:	3b 07       	cpc	r19, r27
    1800:	38 f0       	brcs	.+14     	; 0x1810 <main+0x74e>
				hfe[0] = (rv[0] - 512);
    1802:	20 50       	subi	r18, 0x00	; 0
    1804:	32 40       	sbci	r19, 0x02	; 2
    1806:	30 93 9d 00 	sts	0x009D, r19
    180a:	20 93 9c 00 	sts	0x009C, r18
    180e:	08 c0       	rjmp	.+16     	; 0x1820 <main+0x75e>
			} else {
				hfe[0] = (512 - rv[0]);
    1810:	80 e0       	ldi	r24, 0x00	; 0
    1812:	92 e0       	ldi	r25, 0x02	; 2
    1814:	82 1b       	sub	r24, r18
    1816:	93 0b       	sbc	r25, r19
    1818:	90 93 9d 00 	sts	0x009D, r25
    181c:	80 93 9c 00 	sts	0x009C, r24
			}
			if(rv[1]>512) {
    1820:	80 91 96 00 	lds	r24, 0x0096
    1824:	90 91 97 00 	lds	r25, 0x0097
    1828:	e2 e0       	ldi	r30, 0x02	; 2
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	9e 07       	cpc	r25, r30
    182e:	20 f0       	brcs	.+8      	; 0x1838 <main+0x776>
				hfe[1] = (rv[1] - 512);
    1830:	9c 01       	movw	r18, r24
    1832:	20 50       	subi	r18, 0x00	; 0
    1834:	32 40       	sbci	r19, 0x02	; 2
    1836:	04 c0       	rjmp	.+8      	; 0x1840 <main+0x77e>
			} else {
				hfe[1] = (512 - rv[1]);
    1838:	20 e0       	ldi	r18, 0x00	; 0
    183a:	32 e0       	ldi	r19, 0x02	; 2
    183c:	28 1b       	sub	r18, r24
    183e:	39 0b       	sbc	r19, r25
    1840:	30 93 9f 00 	sts	0x009F, r19
    1844:	20 93 9e 00 	sts	0x009E, r18
			}
			if(hfe[0] > hfe[1])  {
    1848:	40 91 9c 00 	lds	r20, 0x009C
    184c:	50 91 9d 00 	lds	r21, 0x009D
    1850:	20 91 9e 00 	lds	r18, 0x009E
    1854:	30 91 9f 00 	lds	r19, 0x009F
    1858:	24 17       	cp	r18, r20
    185a:	35 07       	cpc	r19, r21
    185c:	88 f4       	brcc	.+34     	; 0x1880 <main+0x7be>
				radcmax[0] = radcmax[1];
    185e:	20 91 81 00 	lds	r18, 0x0081
    1862:	30 91 82 00 	lds	r19, 0x0082
    1866:	30 93 80 00 	sts	0x0080, r19
    186a:	20 93 7f 00 	sts	0x007F, r18
				rv[0] = rv[1];	//Ergebnis verwenden, welches näher an 512 liegt (bessere Genauigkeit)
    186e:	90 93 95 00 	sts	0x0095, r25
    1872:	80 93 94 00 	sts	0x0094, r24
				rv[1] = rhval;	//470k-Testwiderstand	
    1876:	d0 93 97 00 	sts	0x0097, r29
    187a:	c0 93 96 00 	sts	0x0096, r28
    187e:	04 c0       	rjmp	.+8      	; 0x1888 <main+0x7c6>
			} else {
				rv[1] = rlval;	//680R-Testwiderstand
    1880:	b0 92 97 00 	sts	0x0097, r11
    1884:	a0 92 96 00 	sts	0x0096, r10
			}
			if(rv[0]==0) rv[0] = 1;
    1888:	80 91 94 00 	lds	r24, 0x0094
    188c:	90 91 95 00 	lds	r25, 0x0095
    1890:	00 97       	sbiw	r24, 0x00	; 0
    1892:	31 f4       	brne	.+12     	; 0x18a0 <main+0x7de>
    1894:	81 e0       	ldi	r24, 0x01	; 1
    1896:	90 e0       	ldi	r25, 0x00	; 0
    1898:	90 93 95 00 	sts	0x0095, r25
    189c:	80 93 94 00 	sts	0x0094, r24
			lhfe = (unsigned long)((unsigned long)((unsigned long)rv[1] * (unsigned long)rv[0]) / (unsigned long)((unsigned long)radcmax[0] - (unsigned long)rv[0]));	//Widerstand berechnen
    18a0:	e0 90 94 00 	lds	r14, 0x0094
    18a4:	f0 90 95 00 	lds	r15, 0x0095
    18a8:	00 e0       	ldi	r16, 0x00	; 0
    18aa:	10 e0       	ldi	r17, 0x00	; 0
    18ac:	20 91 96 00 	lds	r18, 0x0096
    18b0:	30 91 97 00 	lds	r19, 0x0097
    18b4:	40 e0       	ldi	r20, 0x00	; 0
    18b6:	50 e0       	ldi	r21, 0x00	; 0
    18b8:	c8 01       	movw	r24, r16
    18ba:	b7 01       	movw	r22, r14
    18bc:	1b d1       	rcall	.+566    	; 0x1af4 <__mulsi3>
    18be:	20 91 7f 00 	lds	r18, 0x007F
    18c2:	30 91 80 00 	lds	r19, 0x0080
    18c6:	40 e0       	ldi	r20, 0x00	; 0
    18c8:	50 e0       	ldi	r21, 0x00	; 0
    18ca:	2e 19       	sub	r18, r14
    18cc:	3f 09       	sbc	r19, r15
    18ce:	40 0b       	sbc	r20, r16
    18d0:	51 0b       	sbc	r21, r17
    18d2:	43 d1       	rcall	.+646    	; 0x1b5a <__udivmodsi4>
    18d4:	f9 01       	movw	r30, r18
    18d6:	20 93 90 00 	sts	0x0090, r18
    18da:	f0 93 91 00 	sts	0x0091, r31
    18de:	40 93 92 00 	sts	0x0092, r20
    18e2:	50 93 93 00 	sts	0x0093, r21
			ultoa(lhfe,outval,10);
    18e6:	b9 01       	movw	r22, r18
    18e8:	ca 01       	movw	r24, r20
    18ea:	40 e7       	ldi	r20, 0x70	; 112
    18ec:	50 e0       	ldi	r21, 0x00	; 0
    18ee:	2a e0       	ldi	r18, 0x0A	; 10
    18f0:	30 e0       	ldi	r19, 0x00	; 0
    18f2:	74 d1       	rcall	.+744    	; 0x1bdc <ultoa>

			if(rv[1]==rhval) {	//470k-Widerstand?
    18f4:	80 91 96 00 	lds	r24, 0x0096
    18f8:	90 91 97 00 	lds	r25, 0x0097
    18fc:	8c 17       	cp	r24, r28
    18fe:	9d 07       	cpc	r25, r29
    1900:	61 f5       	brne	.+88     	; 0x195a <main+0x898>
				ra = strlen(outval);	//Nötig, um Komma anzuzeigen
    1902:	f6 01       	movw	r30, r12
    1904:	01 90       	ld	r0, Z+
    1906:	00 20       	and	r0, r0
    1908:	e9 f7       	brne	.-6      	; 0x1904 <main+0x842>
    190a:	31 97       	sbiw	r30, 0x01	; 1
    190c:	e0 57       	subi	r30, 0x70	; 112
    190e:	f0 40       	sbci	r31, 0x00	; 0
    1910:	e0 93 bc 00 	sts	0x00BC, r30
				for(rb=0;rb<ra;rb++) {
    1914:	10 92 6f 00 	sts	0x006F, r1
    1918:	16 c0       	rjmp	.+44     	; 0x1946 <main+0x884>
					lcd_data(outval[rb]);
    191a:	f0 e0       	ldi	r31, 0x00	; 0
    191c:	e0 59       	subi	r30, 0x90	; 144
    191e:	ff 4f       	sbci	r31, 0xFF	; 255
    1920:	80 81       	ld	r24, Z
    1922:	c9 d3       	rcall	.+1938   	; 0x20b6 <__data_load_end+0x40a>
					if(rb==(ra-2)) lcd_data('.');	//Komma
    1924:	20 91 6f 00 	lds	r18, 0x006F
    1928:	30 e0       	ldi	r19, 0x00	; 0
    192a:	80 91 bc 00 	lds	r24, 0x00BC
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	02 97       	sbiw	r24, 0x02	; 2
    1932:	28 17       	cp	r18, r24
    1934:	39 07       	cpc	r19, r25
    1936:	11 f4       	brne	.+4      	; 0x193c <main+0x87a>
    1938:	8e e2       	ldi	r24, 0x2E	; 46
    193a:	bd d3       	rcall	.+1914   	; 0x20b6 <__data_load_end+0x40a>
			lhfe = (unsigned long)((unsigned long)((unsigned long)rv[1] * (unsigned long)rv[0]) / (unsigned long)((unsigned long)radcmax[0] - (unsigned long)rv[0]));	//Widerstand berechnen
			ultoa(lhfe,outval,10);

			if(rv[1]==rhval) {	//470k-Widerstand?
				ra = strlen(outval);	//Nötig, um Komma anzuzeigen
				for(rb=0;rb<ra;rb++) {
    193c:	80 91 6f 00 	lds	r24, 0x006F
    1940:	8f 5f       	subi	r24, 0xFF	; 255
    1942:	80 93 6f 00 	sts	0x006F, r24
    1946:	e0 91 6f 00 	lds	r30, 0x006F
    194a:	80 91 bc 00 	lds	r24, 0x00BC
    194e:	e8 17       	cp	r30, r24
    1950:	20 f3       	brcs	.-56     	; 0x191a <main+0x858>
					lcd_data(outval[rb]);
					if(rb==(ra-2)) lcd_data('.');	//Komma
				}
				lcd_data(' ');
    1952:	80 e2       	ldi	r24, 0x20	; 32
    1954:	b0 d3       	rcall	.+1888   	; 0x20b6 <__data_load_end+0x40a>
				lcd_data ('k'); //Kilo-Ohm, falls 470k-Widerstand verwendet
    1956:	8b e6       	ldi	r24, 0x6B	; 107
    1958:	04 c0       	rjmp	.+8      	; 0x1962 <main+0x8a0>
			} else {
				lcd_string(outval);
    195a:	80 e7       	ldi	r24, 0x70	; 112
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	1a d4       	rcall	.+2100   	; 0x2194 <__data_load_end+0x4e8>
				lcd_data(' ');
    1960:	80 e2       	ldi	r24, 0x20	; 32
    1962:	a9 d3       	rcall	.+1874   	; 0x20b6 <__data_load_end+0x40a>
			}
			lcd_data('O');	//Omega für Ohm 
    1964:	8f e4       	ldi	r24, 0x4F	; 79
    1966:	a7 d3       	rcall	.+1870   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data(0xBC);
    1968:	8c eb       	ldi	r24, 0xBC	; 188
    196a:	76 c0       	rjmp	.+236    	; 0x1a58 <main+0x996>
			goto end;

		} else if(PartFound == PART_CAPACITOR) {	//Kapazitätsmessung auch nur auf Mega8 verfügbar
    196c:	87 30       	cpi	r24, 0x07	; 7
    196e:	09 f0       	breq	.+2      	; 0x1972 <main+0x8b0>
    1970:	53 c0       	rjmp	.+166    	; 0x1a18 <main+0x956>
			lcd_eep_string(Capacitor);
    1972:	89 ee       	ldi	r24, 0xE9	; 233
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	21 d4       	rcall	.+2114   	; 0x21ba <__data_load_end+0x50e>
			lcd_data(ca + 49);	//Pin-Angaben
    1978:	80 91 9b 00 	lds	r24, 0x009B
    197c:	8f 5c       	subi	r24, 0xCF	; 207
    197e:	9b d3       	rcall	.+1846   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data('-');
    1980:	8d e2       	ldi	r24, 0x2D	; 45
    1982:	99 d3       	rcall	.+1842   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data(cb + 49);
    1984:	80 91 69 00 	lds	r24, 0x0069
    1988:	8f 5c       	subi	r24, 0xCF	; 207
    198a:	95 d3       	rcall	.+1834   	; 0x20b6 <__data_load_end+0x40a>
			Line2(); //2. Zeile
    198c:	80 ec       	ldi	r24, 0xC0	; 192
    198e:	b2 d3       	rcall	.+1892   	; 0x20f4 <__data_load_end+0x448>
			tmpval2 = 'n';
    1990:	8e e6       	ldi	r24, 0x6E	; 110
    1992:	80 93 78 00 	sts	0x0078, r24
			if(cv > 99999) {	//ab 1µF
    1996:	60 91 6b 00 	lds	r22, 0x006B
    199a:	70 91 6c 00 	lds	r23, 0x006C
    199e:	80 91 6d 00 	lds	r24, 0x006D
    19a2:	90 91 6e 00 	lds	r25, 0x006E
    19a6:	60 3a       	cpi	r22, 0xA0	; 160
    19a8:	f6 e8       	ldi	r31, 0x86	; 134
    19aa:	7f 07       	cpc	r23, r31
    19ac:	f1 e0       	ldi	r31, 0x01	; 1
    19ae:	8f 07       	cpc	r24, r31
    19b0:	f0 e0       	ldi	r31, 0x00	; 0
    19b2:	9f 07       	cpc	r25, r31
    19b4:	80 f0       	brcs	.+32     	; 0x19d6 <main+0x914>
				cv /= 1000;
    19b6:	28 ee       	ldi	r18, 0xE8	; 232
    19b8:	33 e0       	ldi	r19, 0x03	; 3
    19ba:	40 e0       	ldi	r20, 0x00	; 0
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	cd d0       	rcall	.+410    	; 0x1b5a <__udivmodsi4>
    19c0:	20 93 6b 00 	sts	0x006B, r18
    19c4:	30 93 6c 00 	sts	0x006C, r19
    19c8:	40 93 6d 00 	sts	0x006D, r20
    19cc:	50 93 6e 00 	sts	0x006E, r21
				tmpval2 = LCD_CHAR_U;
    19d0:	85 e7       	ldi	r24, 0x75	; 117
    19d2:	80 93 78 00 	sts	0x0078, r24
			}
			ultoa(cv, outval, 10);
    19d6:	60 91 6b 00 	lds	r22, 0x006B
    19da:	70 91 6c 00 	lds	r23, 0x006C
    19de:	80 91 6d 00 	lds	r24, 0x006D
    19e2:	90 91 6e 00 	lds	r25, 0x006E
    19e6:	40 e7       	ldi	r20, 0x70	; 112
    19e8:	50 e0       	ldi	r21, 0x00	; 0
    19ea:	2a e0       	ldi	r18, 0x0A	; 10
    19ec:	30 e0       	ldi	r19, 0x00	; 0
    19ee:	f6 d0       	rcall	.+492    	; 0x1bdc <ultoa>
			tmpval = strlen(outval);
    19f0:	d6 01       	movw	r26, r12
    19f2:	0d 90       	ld	r0, X+
    19f4:	00 20       	and	r0, r0
    19f6:	e9 f7       	brne	.-6      	; 0x19f2 <main+0x930>
    19f8:	ad 01       	movw	r20, r26
    19fa:	41 50       	subi	r20, 0x01	; 1
    19fc:	50 40       	sbci	r21, 0x00	; 0
    19fe:	40 57       	subi	r20, 0x70	; 112
    1a00:	50 40       	sbci	r21, 0x00	; 0
    1a02:	40 93 6a 00 	sts	0x006A, r20
			lcd_show_format_cap(outval, tmpval, tmpval);
    1a06:	80 e7       	ldi	r24, 0x70	; 112
    1a08:	90 e0       	ldi	r25, 0x00	; 0
    1a0a:	64 2f       	mov	r22, r20
    1a0c:	12 db       	rcall	.-2524   	; 0x1032 <lcd_show_format_cap>
			lcd_data(tmpval2);
    1a0e:	80 91 78 00 	lds	r24, 0x0078
    1a12:	51 d3       	rcall	.+1698   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data('F');
    1a14:	86 e4       	ldi	r24, 0x46	; 70
    1a16:	20 c0       	rjmp	.+64     	; 0x1a58 <main+0x996>
			goto end;
	#endif
	}
	#ifdef UseM8	//Unterscheidung, ob Dioden gefunden wurden oder nicht nur auf Mega8
		if(NumOfDiodes == 0) {
    1a18:	80 91 66 00 	lds	r24, 0x0066
    1a1c:	88 23       	and	r24, r24
    1a1e:	61 f4       	brne	.+24     	; 0x1a38 <main+0x976>
			//Keine Dioden gefunden
			lcd_eep_string(TestFailed1); //"Kein,unbek. oder"
    1a20:	8e e3       	ldi	r24, 0x3E	; 62
    1a22:	90 e0       	ldi	r25, 0x00	; 0
    1a24:	ca d3       	rcall	.+1940   	; 0x21ba <__data_load_end+0x50e>
			Line2(); //2. Zeile
    1a26:	80 ec       	ldi	r24, 0xC0	; 192
    1a28:	65 d3       	rcall	.+1738   	; 0x20f4 <__data_load_end+0x448>
			lcd_eep_string(TestFailed2); //"defektes "
    1a2a:	8e e4       	ldi	r24, 0x4E	; 78
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	c5 d3       	rcall	.+1930   	; 0x21ba <__data_load_end+0x50e>
			lcd_eep_string(Bauteil);
    1a30:	87 e5       	ldi	r24, 0x57	; 87
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	c2 d3       	rcall	.+1924   	; 0x21ba <__data_load_end+0x50e>
    1a36:	11 c0       	rjmp	.+34     	; 0x1a5a <main+0x998>
		} else {
			lcd_eep_string(Bauteil1);
    1a38:	80 e6       	ldi	r24, 0x60	; 96
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	be d3       	rcall	.+1916   	; 0x21ba <__data_load_end+0x50e>
			lcd_eep_string(Unknown); //" unbek."
    1a3e:	89 e6       	ldi	r24, 0x69	; 105
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	bb d3       	rcall	.+1910   	; 0x21ba <__data_load_end+0x50e>
			Line2(); //2. Zeile
    1a44:	80 ec       	ldi	r24, 0xC0	; 192
    1a46:	56 d3       	rcall	.+1708   	; 0x20f4 <__data_load_end+0x448>
			lcd_eep_string(OrBroken); //"oder defekt"
    1a48:	81 ed       	ldi	r24, 0xD1	; 209
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	b6 d3       	rcall	.+1900   	; 0x21ba <__data_load_end+0x50e>
			lcd_data(NumOfDiodes + 48);
    1a4e:	80 91 66 00 	lds	r24, 0x0066
    1a52:	80 5d       	subi	r24, 0xD0	; 208
    1a54:	30 d3       	rcall	.+1632   	; 0x20b6 <__data_load_end+0x40a>
			lcd_data(LCD_CHAR_DIODE);
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	2e d3       	rcall	.+1628   	; 0x20b6 <__data_load_end+0x40a>
		Line2(); //2. Zeile
		lcd_eep_string(TestFailed2); //"defektes "
		lcd_eep_string(Bauteil);
	#endif
	end:
	while(!(ON_PIN_REG & (1<<RST_PIN)));		//warten ,bis Taster losgelassen
    1a5a:	87 9b       	sbis	0x10, 7	; 16
    1a5c:	fe cf       	rjmp	.-4      	; 0x1a5a <main+0x998>
    1a5e:	ef e4       	ldi	r30, 0x4F	; 79
    1a60:	f3 ec       	ldi	r31, 0xC3	; 195
    1a62:	31 97       	sbiw	r30, 0x01	; 1
    1a64:	f1 f7       	brne	.-4      	; 0x1a62 <main+0x9a0>
    1a66:	00 c0       	rjmp	.+0      	; 0x1a68 <main+0x9a6>
    1a68:	00 00       	nop
	_delay_ms(200);
	for(hfe[0] = 0;hfe[0]<10000;hfe[0]++) {
    1a6a:	10 92 9d 00 	sts	0x009D, r1
    1a6e:	10 92 9c 00 	sts	0x009C, r1
    1a72:	0e c0       	rjmp	.+28     	; 0x1a90 <main+0x9ce>
		if(!(ON_PIN_REG & (1<<RST_PIN))) {
    1a74:	87 9b       	sbis	0x10, 7	; 16
    1a76:	8d cb       	rjmp	.-2278   	; 0x1192 <main+0xd0>
			/*Wenn der Taster wieder gedrückt wurde...
			wieder zum Anfang springen und neuen Test durchführen
			*/
			goto start;
		}
		wdt_reset();
    1a78:	a8 95       	wdr
    1a7a:	a9 ef       	ldi	r26, 0xF9	; 249
    1a7c:	b0 e0       	ldi	r27, 0x00	; 0
    1a7e:	11 97       	sbiw	r26, 0x01	; 1
    1a80:	f1 f7       	brne	.-4      	; 0x1a7e <main+0x9bc>
    1a82:	00 c0       	rjmp	.+0      	; 0x1a84 <main+0x9c2>
    1a84:	00 00       	nop
		lcd_eep_string(Bauteil);
	#endif
	end:
	while(!(ON_PIN_REG & (1<<RST_PIN)));		//warten ,bis Taster losgelassen
	_delay_ms(200);
	for(hfe[0] = 0;hfe[0]<10000;hfe[0]++) {
    1a86:	01 96       	adiw	r24, 0x01	; 1
    1a88:	90 93 9d 00 	sts	0x009D, r25
    1a8c:	80 93 9c 00 	sts	0x009C, r24
    1a90:	80 91 9c 00 	lds	r24, 0x009C
    1a94:	90 91 9d 00 	lds	r25, 0x009D
    1a98:	b7 e2       	ldi	r27, 0x27	; 39
    1a9a:	80 31       	cpi	r24, 0x10	; 16
    1a9c:	9b 07       	cpc	r25, r27
    1a9e:	50 f3       	brcs	.-44     	; 0x1a74 <main+0x9b2>
			goto start;
		}
		wdt_reset();
		_delay_ms(1);
	}
	ON_PORT &= ~(1<<ON_PIN);	//Abschalten
    1aa0:	96 98       	cbi	0x12, 6	; 18
	wdt_disable();	//Watchdog aus
    1aa2:	88 e1       	ldi	r24, 0x18	; 24
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	f8 94       	cli
    1aa8:	81 bd       	out	0x21, r24	; 33
    1aaa:	11 bc       	out	0x21, r1	; 33
    1aac:	0f be       	out	0x3f, r0	; 63
	//Endlosschleife
	while(1) {
		if(!(ON_PIN_REG & (1<<RST_PIN))) {	
    1aae:	87 99       	sbic	0x10, 7	; 16
    1ab0:	fe cf       	rjmp	.-4      	; 0x1aae <main+0x9ec>
    1ab2:	6f cb       	rjmp	.-2338   	; 0x1192 <main+0xd0>

00001ab4 <uart_putc>:
;***************************************************************************

.global uart_putc
.func uart_putc
uart_putc:	
		push bitcnt
    1ab4:	2f 93       	push	r18
		in temp,_SFR_IO_ADDR(SREG)
    1ab6:	5f b7       	in	r21, 0x3f	; 63
    	push bitcnt
    1ab8:	2f 93       	push	r18
		ldi	bitcnt,10	;1+8+sb (sb is # of stop bits)
    1aba:	2a e0       	ldi	r18, 0x0A	; 10
		com	Txbyte		;Inverte everything
    1abc:	80 95       	com	r24
		sec			;Start bit
    1abe:	08 94       	sec

00001ac0 <putchar0>:

putchar0:	brcc	putchar1	;If carry set
    1ac0:	10 f4       	brcc	.+4      	; 0x1ac6 <putchar1>
		#ifdef SWUART_INVERT
			sbi	S_PORT,TxD	;    send a '0'
    1ac2:	ab 9a       	sbi	0x15, 3	; 21
		#else
			cbi	S_PORT,TxD	;    send a '0'
		#endif
		rjmp	putchar2	;else	
    1ac4:	02 c0       	rjmp	.+4      	; 0x1aca <putchar2>

00001ac6 <putchar1>:

putchar1:	
		#ifdef SWUART_INVERT
			cbi	S_PORT,TxD	;    send a '1'
    1ac6:	ab 98       	cbi	0x15, 3	; 21
	...

00001aca <putchar2>:
		#else
			sbi	S_PORT,TxD	;    send a '1'
		#endif
		nop

putchar2:	rcall UART_delay	;One bit delay
    1aca:	08 d0       	rcall	.+16     	; 0x1adc <UART_delay>
		rcall UART_delay
    1acc:	07 d0       	rcall	.+14     	; 0x1adc <UART_delay>

		lsr	Txbyte		;Get next bit
    1ace:	86 95       	lsr	r24
		dec	bitcnt		;If not all bit sent
    1ad0:	2a 95       	dec	r18
		brne	putchar0	;   send next
    1ad2:	b1 f7       	brne	.-20     	; 0x1ac0 <putchar0>
					;else
		pop bitcnt
    1ad4:	2f 91       	pop	r18
    	out _SFR_IO_ADDR(SREG),temp
    1ad6:	5f bf       	out	0x3f, r21	; 63
    	pop bitcnt
    1ad8:	2f 91       	pop	r18
		ret			;   return
    1ada:	08 95       	ret

00001adc <UART_delay>:

.endfunc


UART_delay:	
	push temp	//2
    1adc:	5f 93       	push	r21
	in temp,_SFR_IO_ADDR(SREG)	//1
    1ade:	5f b7       	in	r21, 0x3f	; 63
    push temp	//2
    1ae0:	5f 93       	push	r21
	nop
    1ae2:	00 00       	nop

	ldi temp,62	//2,4kBaud bei 1MHz
    1ae4:	5e e3       	ldi	r21, 0x3E	; 62

00001ae6 <UART_delay1>:
UART_delay1:	
	dec	temp
    1ae6:	5a 95       	dec	r21
	brne	UART_delay1
    1ae8:	f1 f7       	brne	.-4      	; 0x1ae6 <UART_delay1>

	nop
    1aea:	00 00       	nop
	pop temp	//2
    1aec:	5f 91       	pop	r21
    out _SFR_IO_ADDR(SREG),temp	//1
    1aee:	5f bf       	out	0x3f, r21	; 63
    pop temp	//2
    1af0:	5f 91       	pop	r21

ret
    1af2:	08 95       	ret

00001af4 <__mulsi3>:
    1af4:	62 9f       	mul	r22, r18
    1af6:	d0 01       	movw	r26, r0
    1af8:	73 9f       	mul	r23, r19
    1afa:	f0 01       	movw	r30, r0
    1afc:	82 9f       	mul	r24, r18
    1afe:	e0 0d       	add	r30, r0
    1b00:	f1 1d       	adc	r31, r1
    1b02:	64 9f       	mul	r22, r20
    1b04:	e0 0d       	add	r30, r0
    1b06:	f1 1d       	adc	r31, r1
    1b08:	92 9f       	mul	r25, r18
    1b0a:	f0 0d       	add	r31, r0
    1b0c:	83 9f       	mul	r24, r19
    1b0e:	f0 0d       	add	r31, r0
    1b10:	74 9f       	mul	r23, r20
    1b12:	f0 0d       	add	r31, r0
    1b14:	65 9f       	mul	r22, r21
    1b16:	f0 0d       	add	r31, r0
    1b18:	99 27       	eor	r25, r25
    1b1a:	72 9f       	mul	r23, r18
    1b1c:	b0 0d       	add	r27, r0
    1b1e:	e1 1d       	adc	r30, r1
    1b20:	f9 1f       	adc	r31, r25
    1b22:	63 9f       	mul	r22, r19
    1b24:	b0 0d       	add	r27, r0
    1b26:	e1 1d       	adc	r30, r1
    1b28:	f9 1f       	adc	r31, r25
    1b2a:	bd 01       	movw	r22, r26
    1b2c:	cf 01       	movw	r24, r30
    1b2e:	11 24       	eor	r1, r1
    1b30:	08 95       	ret

00001b32 <__udivmodhi4>:
    1b32:	aa 1b       	sub	r26, r26
    1b34:	bb 1b       	sub	r27, r27
    1b36:	51 e1       	ldi	r21, 0x11	; 17
    1b38:	07 c0       	rjmp	.+14     	; 0x1b48 <__udivmodhi4_ep>

00001b3a <__udivmodhi4_loop>:
    1b3a:	aa 1f       	adc	r26, r26
    1b3c:	bb 1f       	adc	r27, r27
    1b3e:	a6 17       	cp	r26, r22
    1b40:	b7 07       	cpc	r27, r23
    1b42:	10 f0       	brcs	.+4      	; 0x1b48 <__udivmodhi4_ep>
    1b44:	a6 1b       	sub	r26, r22
    1b46:	b7 0b       	sbc	r27, r23

00001b48 <__udivmodhi4_ep>:
    1b48:	88 1f       	adc	r24, r24
    1b4a:	99 1f       	adc	r25, r25
    1b4c:	5a 95       	dec	r21
    1b4e:	a9 f7       	brne	.-22     	; 0x1b3a <__udivmodhi4_loop>
    1b50:	80 95       	com	r24
    1b52:	90 95       	com	r25
    1b54:	bc 01       	movw	r22, r24
    1b56:	cd 01       	movw	r24, r26
    1b58:	08 95       	ret

00001b5a <__udivmodsi4>:
    1b5a:	a1 e2       	ldi	r26, 0x21	; 33
    1b5c:	1a 2e       	mov	r1, r26
    1b5e:	aa 1b       	sub	r26, r26
    1b60:	bb 1b       	sub	r27, r27
    1b62:	fd 01       	movw	r30, r26
    1b64:	0d c0       	rjmp	.+26     	; 0x1b80 <__udivmodsi4_ep>

00001b66 <__udivmodsi4_loop>:
    1b66:	aa 1f       	adc	r26, r26
    1b68:	bb 1f       	adc	r27, r27
    1b6a:	ee 1f       	adc	r30, r30
    1b6c:	ff 1f       	adc	r31, r31
    1b6e:	a2 17       	cp	r26, r18
    1b70:	b3 07       	cpc	r27, r19
    1b72:	e4 07       	cpc	r30, r20
    1b74:	f5 07       	cpc	r31, r21
    1b76:	20 f0       	brcs	.+8      	; 0x1b80 <__udivmodsi4_ep>
    1b78:	a2 1b       	sub	r26, r18
    1b7a:	b3 0b       	sbc	r27, r19
    1b7c:	e4 0b       	sbc	r30, r20
    1b7e:	f5 0b       	sbc	r31, r21

00001b80 <__udivmodsi4_ep>:
    1b80:	66 1f       	adc	r22, r22
    1b82:	77 1f       	adc	r23, r23
    1b84:	88 1f       	adc	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	1a 94       	dec	r1
    1b8a:	69 f7       	brne	.-38     	; 0x1b66 <__udivmodsi4_loop>
    1b8c:	60 95       	com	r22
    1b8e:	70 95       	com	r23
    1b90:	80 95       	com	r24
    1b92:	90 95       	com	r25
    1b94:	9b 01       	movw	r18, r22
    1b96:	ac 01       	movw	r20, r24
    1b98:	bd 01       	movw	r22, r26
    1b9a:	cf 01       	movw	r24, r30
    1b9c:	08 95       	ret

00001b9e <itoa>:
    1b9e:	fb 01       	movw	r30, r22
    1ba0:	9f 01       	movw	r18, r30
    1ba2:	e8 94       	clt
    1ba4:	42 30       	cpi	r20, 0x02	; 2
    1ba6:	bc f0       	brlt	.+46     	; 0x1bd6 <itoa+0x38>
    1ba8:	45 32       	cpi	r20, 0x25	; 37
    1baa:	ac f4       	brge	.+42     	; 0x1bd6 <itoa+0x38>
    1bac:	4a 30       	cpi	r20, 0x0A	; 10
    1bae:	29 f4       	brne	.+10     	; 0x1bba <itoa+0x1c>
    1bb0:	97 fb       	bst	r25, 7
    1bb2:	1e f4       	brtc	.+6      	; 0x1bba <itoa+0x1c>
    1bb4:	90 95       	com	r25
    1bb6:	81 95       	neg	r24
    1bb8:	9f 4f       	sbci	r25, 0xFF	; 255
    1bba:	64 2f       	mov	r22, r20
    1bbc:	77 27       	eor	r23, r23
    1bbe:	b9 df       	rcall	.-142    	; 0x1b32 <__udivmodhi4>
    1bc0:	80 5d       	subi	r24, 0xD0	; 208
    1bc2:	8a 33       	cpi	r24, 0x3A	; 58
    1bc4:	0c f0       	brlt	.+2      	; 0x1bc8 <itoa+0x2a>
    1bc6:	89 5d       	subi	r24, 0xD9	; 217
    1bc8:	81 93       	st	Z+, r24
    1bca:	cb 01       	movw	r24, r22
    1bcc:	00 97       	sbiw	r24, 0x00	; 0
    1bce:	a9 f7       	brne	.-22     	; 0x1bba <itoa+0x1c>
    1bd0:	16 f4       	brtc	.+4      	; 0x1bd6 <itoa+0x38>
    1bd2:	5d e2       	ldi	r21, 0x2D	; 45
    1bd4:	51 93       	st	Z+, r21
    1bd6:	10 82       	st	Z, r1
    1bd8:	c9 01       	movw	r24, r18
    1bda:	44 c0       	rjmp	.+136    	; 0x1c64 <strrev>

00001bdc <ultoa>:
    1bdc:	fa 01       	movw	r30, r20
    1bde:	cf 93       	push	r28
    1be0:	ff 93       	push	r31
    1be2:	ef 93       	push	r30
    1be4:	22 30       	cpi	r18, 0x02	; 2
    1be6:	c4 f0       	brlt	.+48     	; 0x1c18 <ultoa+0x3c>
    1be8:	25 32       	cpi	r18, 0x25	; 37
    1bea:	b4 f4       	brge	.+44     	; 0x1c18 <ultoa+0x3c>
    1bec:	c2 2f       	mov	r28, r18
    1bee:	2c 2f       	mov	r18, r28
    1bf0:	33 27       	eor	r19, r19
    1bf2:	44 27       	eor	r20, r20
    1bf4:	55 27       	eor	r21, r21
    1bf6:	ff 93       	push	r31
    1bf8:	ef 93       	push	r30
    1bfa:	af df       	rcall	.-162    	; 0x1b5a <__udivmodsi4>
    1bfc:	ef 91       	pop	r30
    1bfe:	ff 91       	pop	r31
    1c00:	60 5d       	subi	r22, 0xD0	; 208
    1c02:	6a 33       	cpi	r22, 0x3A	; 58
    1c04:	0c f0       	brlt	.+2      	; 0x1c08 <ultoa+0x2c>
    1c06:	69 5d       	subi	r22, 0xD9	; 217
    1c08:	61 93       	st	Z+, r22
    1c0a:	b9 01       	movw	r22, r18
    1c0c:	ca 01       	movw	r24, r20
    1c0e:	60 50       	subi	r22, 0x00	; 0
    1c10:	70 40       	sbci	r23, 0x00	; 0
    1c12:	80 40       	sbci	r24, 0x00	; 0
    1c14:	90 40       	sbci	r25, 0x00	; 0
    1c16:	59 f7       	brne	.-42     	; 0x1bee <ultoa+0x12>
    1c18:	10 82       	st	Z, r1
    1c1a:	8f 91       	pop	r24
    1c1c:	9f 91       	pop	r25
    1c1e:	cf 91       	pop	r28
    1c20:	21 c0       	rjmp	.+66     	; 0x1c64 <strrev>

00001c22 <utoa>:
    1c22:	fb 01       	movw	r30, r22
    1c24:	9f 01       	movw	r18, r30
    1c26:	42 30       	cpi	r20, 0x02	; 2
    1c28:	6c f0       	brlt	.+26     	; 0x1c44 <utoa+0x22>
    1c2a:	45 32       	cpi	r20, 0x25	; 37
    1c2c:	5c f4       	brge	.+22     	; 0x1c44 <utoa+0x22>
    1c2e:	64 2f       	mov	r22, r20
    1c30:	77 27       	eor	r23, r23
    1c32:	7f df       	rcall	.-258    	; 0x1b32 <__udivmodhi4>
    1c34:	80 5d       	subi	r24, 0xD0	; 208
    1c36:	8a 33       	cpi	r24, 0x3A	; 58
    1c38:	0c f0       	brlt	.+2      	; 0x1c3c <utoa+0x1a>
    1c3a:	89 5d       	subi	r24, 0xD9	; 217
    1c3c:	81 93       	st	Z+, r24
    1c3e:	cb 01       	movw	r24, r22
    1c40:	00 97       	sbiw	r24, 0x00	; 0
    1c42:	a9 f7       	brne	.-22     	; 0x1c2e <utoa+0xc>
    1c44:	10 82       	st	Z, r1
    1c46:	c9 01       	movw	r24, r18
    1c48:	0d c0       	rjmp	.+26     	; 0x1c64 <strrev>

00001c4a <__eerd_byte_m8>:
    1c4a:	e1 99       	sbic	0x1c, 1	; 28
    1c4c:	fe cf       	rjmp	.-4      	; 0x1c4a <__eerd_byte_m8>
    1c4e:	9f bb       	out	0x1f, r25	; 31
    1c50:	8e bb       	out	0x1e, r24	; 30
    1c52:	e0 9a       	sbi	0x1c, 0	; 28
    1c54:	99 27       	eor	r25, r25
    1c56:	8d b3       	in	r24, 0x1d	; 29
    1c58:	08 95       	ret

00001c5a <__eerd_word_m8>:
    1c5a:	a8 e1       	ldi	r26, 0x18	; 24
    1c5c:	b0 e0       	ldi	r27, 0x00	; 0
    1c5e:	42 e0       	ldi	r20, 0x02	; 2
    1c60:	50 e0       	ldi	r21, 0x00	; 0
    1c62:	12 c0       	rjmp	.+36     	; 0x1c88 <__eerd_blraw_m8>

00001c64 <strrev>:
    1c64:	dc 01       	movw	r26, r24
    1c66:	fc 01       	movw	r30, r24
    1c68:	67 2f       	mov	r22, r23
    1c6a:	71 91       	ld	r23, Z+
    1c6c:	77 23       	and	r23, r23
    1c6e:	e1 f7       	brne	.-8      	; 0x1c68 <strrev+0x4>
    1c70:	32 97       	sbiw	r30, 0x02	; 2
    1c72:	04 c0       	rjmp	.+8      	; 0x1c7c <strrev+0x18>
    1c74:	7c 91       	ld	r23, X
    1c76:	6d 93       	st	X+, r22
    1c78:	70 83       	st	Z, r23
    1c7a:	62 91       	ld	r22, -Z
    1c7c:	ae 17       	cp	r26, r30
    1c7e:	bf 07       	cpc	r27, r31
    1c80:	c8 f3       	brcs	.-14     	; 0x1c74 <strrev+0x10>
    1c82:	08 95       	ret

00001c84 <__eerd_block_m8>:
    1c84:	dc 01       	movw	r26, r24
    1c86:	cb 01       	movw	r24, r22

00001c88 <__eerd_blraw_m8>:
    1c88:	fc 01       	movw	r30, r24
    1c8a:	e1 99       	sbic	0x1c, 1	; 28
    1c8c:	fe cf       	rjmp	.-4      	; 0x1c8a <__eerd_blraw_m8+0x2>
    1c8e:	06 c0       	rjmp	.+12     	; 0x1c9c <__eerd_blraw_m8+0x14>
    1c90:	ff bb       	out	0x1f, r31	; 31
    1c92:	ee bb       	out	0x1e, r30	; 30
    1c94:	e0 9a       	sbi	0x1c, 0	; 28
    1c96:	31 96       	adiw	r30, 0x01	; 1
    1c98:	0d b2       	in	r0, 0x1d	; 29
    1c9a:	0d 92       	st	X+, r0
    1c9c:	41 50       	subi	r20, 0x01	; 1
    1c9e:	50 40       	sbci	r21, 0x00	; 0
    1ca0:	b8 f7       	brcc	.-18     	; 0x1c90 <__eerd_blraw_m8+0x8>
    1ca2:	08 95       	ret

00001ca4 <_exit>:
    1ca4:	f8 94       	cli

00001ca6 <__stop_program>:
    1ca6:	ff cf       	rjmp	.-2      	; 0x1ca6 <__stop_program>
